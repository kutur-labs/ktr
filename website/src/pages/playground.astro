---
import MainLayout from "../layouts/main-layout.astro";
import tshirtKtr from "./tshirt.ktr?raw";
import petalKtr from "./petal.ktr?raw";
const sources = { tshirt: tshirtKtr, petal: petalKtr };
---

<MainLayout headerBorder>
  <main class="flex flex-col" style="height: calc(100dvh - 4rem);">
    <div
      class="grid grid-cols-1 md:grid-cols-2 grid-rows-4 md:grid-rows-2 flex-1 min-h-0"
    >
      <!-- Top-left: source.ktr editor -->
      <div
        class="flex flex-col min-h-0 min-w-0 border-b md:border-r border-border overflow-hidden"
      >
        <div
          class="flex items-center justify-between px-3 h-7 border-b border-border shrink-0"
        >
          <div class="flex items-center gap-1.5">
            <div class="flex items-center gap-4">
              <button
                id="tab-tshirt"
                class="py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary"
                >T-shirt</button
              >
              <button
                id="tab-petal"
                class="py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary-muted-foreground/50"
                >Petal</button
              >
            </div>
          </div>
          <span
            id="status-compile"
            class="text-[10px] font-mono text-primary-muted-foreground/50"
          ></span>
        </div>
        <div id="editor-input" class="flex-1 min-h-0 overflow-hidden"></div>
      </div>

      <!-- Top-right: inputs -->
      <div
        id="inputs-pane"
        class="flex flex-col min-h-0 min-w-0 border-b border-border overflow-hidden"
      >
        <div
          class="flex items-center justify-between px-3 h-7 border-b border-border shrink-0"
        >
          <div class="flex items-center gap-1.5">
            <span class="text-[10px] font-mono text-primary-muted-foreground"
              >Input</span
            >
            <button
              id="toggle-animate"
              class="cursor-pointer text-primary-muted-foreground/60 hover:text-primary-muted-foreground ml-1 leading-none"
              title="Play/pause animation"
              ><svg
                id="icon-pause"
                class="size-2 hidden"
                viewBox="0 0 16 16"
                fill="currentColor"
                xmlns="http://www.w3.org/2000/svg"
                ><rect x="3" y="2" width="4" height="12" rx="1"></rect><rect
                  x="9"
                  y="2"
                  width="4"
                  height="12"
                  rx="1"></rect></svg
              ><svg
                id="icon-play"
                class="size-2"
                viewBox="0 0 16 16"
                fill="currentColor"
                xmlns="http://www.w3.org/2000/svg"
                ><path
                  d="M4 2.5a.5.5 0 01.77-.42l9 5.5a.5.5 0 010 .84l-9 5.5A.5.5 0 014 13.5v-11z"
                ></path></svg
              ></button
            ><button
              id="reset-inputs"
              class="cursor-pointer text-primary-muted-foreground/60 hover:text-primary-muted-foreground ml-0.5 leading-none"
              title="Reset inputs"
              ><svg
                class="size-2"
                viewBox="0 0 16 16"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                ><path
                  d="M2 2v5h5M14 14v-5H9"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"></path><path
                  d="M13.5 6A6 6 0 005 3.5L2 7m12 3l-3 3.5A6 6 0 012.5 10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"></path></svg
              ></button
            >
          </div>
          <span
            id="status-eval"
            class="text-[10px] font-mono text-primary-muted-foreground/50"
          ></span>
        </div>
        <div
          id="inputs-content"
          class="px-3 py-2 font-mono text-xs flex-1 overflow-auto"
        >
        </div>
      </div>

      <!-- Bottom-left: source.ktrir editor -->
      <div
        class="flex flex-col min-h-0 min-w-0 border-b md:border-b-0 md:border-r border-border overflow-hidden"
      >
        <div
          class="flex items-center justify-between px-3 h-7 border-b border-border shrink-0"
        >
          <div class="flex items-center gap-1.5">
            <span class="text-[10px] font-mono text-primary-muted-foreground"
              >IR</span
            >
          </div>
          <span
            id="status"
            class="text-[10px] font-mono text-primary-muted-foreground/50"
          ></span>
        </div>
        <div id="editor-output" class="flex-1 min-h-0 overflow-hidden"></div>
      </div>

      <!-- Bottom-right: output (visual / text) -->
      <div class="flex flex-col min-h-0 min-w-0 overflow-hidden">
        <div
          class="flex items-center justify-between px-3 h-7 border-b border-border shrink-0"
        >
          <div class="flex items-center gap-1.5">
            <span class="text-[10px] font-mono text-primary-muted-foreground"
              >Output</span
            >
            <button
              id="download-svg"
              class="cursor-pointer text-primary-muted-foreground/60 hover:text-primary-muted-foreground ml-1 leading-none"
              title="Download SVG"
              ><svg
                class="size-2"
                viewBox="0 0 16 16"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                ><path
                  d="M8 1v9m0 0L4.5 6.5M8 10l3.5-3.5M2 12.5v1a1 1 0 001 1h10a1 1 0 001-1v-1"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"></path></svg
              ></button
            >
          </div>
          <div class="flex items-center gap-4">
            <button
              id="toggle-visual"
              class="py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary"
              >Visual</button
            >
            <button
              id="toggle-text"
              class="py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary-muted-foreground/50"
              >Text</button
            >
          </div>
        </div>
        <div
          id="visual-output"
          class="flex-1 min-h-0 overflow-auto flex items-center justify-center"
        >
        </div>
        <div id="text-output" class="hidden flex-1 min-h-0 overflow-auto">
          <div id="results-content" class="px-3 py-2 font-mono text-xs"></div>
        </div>
      </div>
    </div>

    <!-- Bottom bar (fixed height to prevent layout shift) -->
    <div
      class="flex items-center justify-between gap-4 px-3 border-t border-border shrink-0 h-8 overflow-hidden"
    >
      <div
        id="error-bar"
        class="text-primary text-xs font-mono truncate flex-1"
      >
      </div>
      <span
        id="version-info"
        class="text-[10px] font-mono text-primary-muted-foreground/60 shrink-0 whitespace-nowrap"
      ></span>
    </div>
  </main>
</MainLayout>

<!-- Default code passed from Astro frontmatter -->
<script
  id="default-code"
  type="application/json"
  set:html={JSON.stringify(sources)}
/>

<style is:global>
  .monaco-editor .hover-row.status-bar .actions a {
    color: var(--primary) !important;
  }
  .svg-point {
    transition: opacity 0.15s ease;
  }
  .svg-point:hover text {
    fill-opacity: 1;
  }
  svg:has(.svg-point:hover) .svg-point:not(:hover) {
    opacity: 0.35;
  }
  svg:has(.svg-point:hover) path,
  svg:has(.svg-point:hover) line {
    opacity: 0.35;
  }
</style>

<!-- Monaco AMD loader from CDN -->
<script
  is:inline
  src="https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs/loader.js"
></script>

<script is:inline>
  // ─── Monaco setup ─────────────────────────────────────────────────────────

  var MONACO_CDN = "https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs";

  require.config({ paths: { vs: MONACO_CDN } });

  window.MonacoEnvironment = {
    getWorkerUrl: function () {
      return (
        "data:text/javascript;charset=utf-8," +
        encodeURIComponent(
          'self.MonacoEnvironment={baseUrl:"' +
            MONACO_CDN +
            '/"};importScripts("' +
            MONACO_CDN +
            '/base/worker/workerMain.js");',
        )
      );
    },
  };

  // ─── WASM ─────────────────────────────────────────────────────────────────

  var wasm = null;
  var wasmRuntime = null;
  var encoder = new TextEncoder();
  var decoder = new TextDecoder();

  function loadWasm() {
    return WebAssembly.instantiateStreaming(fetch("/ktrc.wasm"), {}).then(
      function (result) {
        return result.instance.exports;
      },
    );
  }

  function loadRuntimeWasm() {
    return WebAssembly.instantiateStreaming(fetch("/ktrr.wasm"), {}).then(
      function (result) {
        return result.instance.exports;
      },
    );
  }

  function writeToWasm(wasmInstance, text) {
    var encoded = encoder.encode(text);
    var ptr = wasmInstance.alloc(encoded.length);
    if (ptr === 0) throw new Error("WASM alloc failed");
    new Uint8Array(wasmInstance.memory.buffer, ptr, encoded.length).set(
      encoded,
    );
    return { ptr: ptr, len: encoded.length };
  }

  function readFromWasm(wasmInstance, ptr, len) {
    if (ptr === 0 || len === 0) return "";
    return decoder.decode(new Uint8Array(wasmInstance.memory.buffer, ptr, len));
  }

  function compileKtr(source) {
    var input = writeToWasm(wasm, source);
    try {
      var result = wasm.compile(input.ptr, input.len);
      if (result >= 0) {
        return {
          ok: true,
          output: readFromWasm(wasm, wasm.get_output_ptr(), result),
        };
      } else {
        var errPtr = wasm.get_error_ptr();
        var errLen = wasm.get_error_len();
        return {
          ok: false,
          error: readFromWasm(wasm, errPtr, errLen) || "Compilation failed",
        };
      }
    } finally {
      wasm.dealloc(input.ptr, input.len);
    }
  }

  function decompileIr(irSource) {
    var input = writeToWasm(wasm, irSource);
    try {
      var result = wasm.decompile_ir(input.ptr, input.len);
      if (result >= 0) {
        return {
          ok: true,
          output: readFromWasm(wasm, wasm.get_output_ptr(), result),
        };
      } else {
        var errPtr = wasm.get_error_ptr();
        var errLen = wasm.get_error_len();
        return {
          ok: false,
          error: readFromWasm(wasm, errPtr, errLen) || "Decompilation failed",
        };
      }
    } finally {
      wasm.dealloc(input.ptr, input.len);
    }
  }

  function evalIr(irSource, overrides) {
    if (!wasmRuntime) return null;

    // Set overrides via the WASM API.
    wasmRuntime.clear_overrides();
    if (overrides) {
      var keys = Object.keys(overrides);
      for (var i = 0; i < keys.length; i++) {
        var name = writeToWasm(wasmRuntime, keys[i]);
        wasmRuntime.set_override(name.ptr, name.len, overrides[keys[i]]);
        wasmRuntime.dealloc(name.ptr, name.len);
      }
    }

    var input = writeToWasm(wasmRuntime, irSource);
    try {
      var result = wasmRuntime.eval_ir(input.ptr, input.len);
      if (result >= 0) {
        var json = readFromWasm(
          wasmRuntime,
          wasmRuntime.get_output_ptr(),
          result,
        );
        return { ok: true, bindings: JSON.parse(json) };
      } else {
        var errPtr = wasmRuntime.get_error_ptr();
        var errLen = wasmRuntime.get_error_len();
        return {
          ok: false,
          error:
            readFromWasm(wasmRuntime, errPtr, errLen) || "Evaluation failed",
        };
      }
    } finally {
      wasmRuntime.dealloc(input.ptr, input.len);
    }
  }

  // ─── Monaco initialization ────────────────────────────────────────────────

  require(["vs/editor/editor.main"], function () {
    // Register ktr language
    monaco.languages.register({ id: "ktr" });
    monaco.languages.setMonarchTokensProvider("ktr", {
      keywords: [
        "input",
        "fn",
        "let",
        "return",
        "require",
        "export",
        "search",
        "assert",
        "as",
      ],
      searchKeywords: ["bounds", "initial", "tolerance"],
      typeKeywords: [
        "mm",
        "cm",
        "f64",
        "i64",
        "bool",
        "point",
        "bezier",
        "line",
        "length",
        "percentage",
      ],

      tokenizer: {
        root: [
          [/\/\/.*$/, "comment"],
          [/"(?:[^"\\]|\\.)*"/, "string"],
          [/\b\d+(\.\d+)?(mm|cm)\b/, "number.unit"],
          [/\b\d+(\.\d+)?%/, "number.percentage"],
          [/\b\d+\.\d+\b/, "number.float"],
          [/\b\d+\b/, "number"],
          [
            /[a-zA-Z_]\w*/,
            {
              cases: {
                "@keywords": "keyword",
                "@searchKeywords": "keyword.other",
                "@typeKeywords": "type",
                "@default": "identifier",
              },
            },
          ],
          [/==|!=|<=|>=|<|>/, "operator"],
          [/[+\-*/]/, "operator"],
          [/\.\./, "operator"],
          [/=/, "operator"],
          [/[{}()\[\]]/, "delimiter.bracket"],
          [/[:,]/, "delimiter"],
          [/\./, "delimiter"],
        ],
      },
    });

    // Register ktrir language
    monaco.languages.register({ id: "ktrir" });
    monaco.languages.setMonarchTokensProvider("ktrir", {
      tokenizer: {
        root: [
          [/#.*$/, "comment"],
          [/\b(input|fn|end|ret|call)\b/, "keyword"],
          [/%[a-zA-Z_]\w*/, "variable"],
          [/%\d+/, "variable"],
          [/\b(length|percentage|f64|point|bezier|line|bool)\b/, "type"],
          [/\b(add|sub|mul|div|point|bezier|line|point_x|point_y|line_p1|line_p2|bezier_p1|bezier_p2|bezier_p3|bezier_p4)\b(?=\s)/, "keyword.other"],
          [/\b\d+(\.\d+)?(mm|cm)\b/, "number.unit"],
          [/\b\d+\.\d+\b/, "number.float"],
          [/\b\d+\b/, "number"],
          [/->/, "operator"],
          [/:/, "delimiter"],
          [/=/, "operator"],
        ],
      },
    });

    // ── Themes ────────────────────────────────────────────────────────────────

    monaco.editor.defineTheme("ktr-light", {
      base: "vs",
      inherit: false,
      rules: [
        { token: "comment", foreground: "998888" },
        { token: "string", foreground: "B87333" },
        { token: "keyword", foreground: "C41E3A" },
        { token: "keyword.other", foreground: "C41E3A" },
        { token: "type", foreground: "986801" },
        { token: "number", foreground: "B76B01" },
        { token: "number.unit", foreground: "B76B01" },
        { token: "number.float", foreground: "B76B01" },
        { token: "number.percentage", foreground: "B76B01" },
        { token: "operator", foreground: "5C4444" },
        { token: "delimiter", foreground: "5C4444" },
        { token: "delimiter.bracket", foreground: "5C4444" },
        { token: "variable", foreground: "C41E3A" },
        { token: "identifier", foreground: "3D2323" },
        { token: "", foreground: "3D2323" },
      ],
      colors: {
        "editor.background": "#00000000",
        "editor.foreground": "#3D2323",
        "editor.lineHighlightBackground": "#00000006",
        "editorLineNumber.foreground": "#99888866",
        "editorLineNumber.activeForeground": "#99888899",
        "editorCursor.foreground": "#C41E3A",
        "editor.selectionBackground": "#C41E3A30",
        "editor.inactiveSelectionBackground": "#C41E3A15",
        "editorIndentGuide.background": "#00000008",
        focusBorder: "#00000000",
        "editorHoverWidget.background": "#FDF8F6",
        "editorHoverWidget.border": "#3D232318",
        "editorHoverWidget.foreground": "#3D2323",
        "editorHoverWidget.statusBarBackground": "#F5EEEB",
        "editorMarkerNavigation.background": "#FDF8F6",
        "editorMarkerNavigationError.background": "#C41E3A20",
      },
    });

    monaco.editor.defineTheme("ktr-dark", {
      base: "vs-dark",
      inherit: false,
      rules: [
        { token: "comment", foreground: "7F8C8D" },
        { token: "string", foreground: "E8A87C" },
        { token: "keyword", foreground: "D66A57" },
        { token: "keyword.other", foreground: "D66A57" },
        { token: "type", foreground: "E5C07B" },
        { token: "number", foreground: "D19A66" },
        { token: "number.unit", foreground: "D19A66" },
        { token: "number.float", foreground: "D19A66" },
        { token: "number.percentage", foreground: "D19A66" },
        { token: "operator", foreground: "ABB2BF" },
        { token: "delimiter", foreground: "ABB2BF" },
        { token: "delimiter.bracket", foreground: "ABB2BF" },
        { token: "variable", foreground: "D66A57" },
        { token: "identifier", foreground: "E0D6C8" },
        { token: "", foreground: "E0D6C8" },
      ],
      colors: {
        "editor.background": "#00000000",
        "editor.foreground": "#E0D6C8",
        "editor.lineHighlightBackground": "#FFFFFF06",
        "editorLineNumber.foreground": "#ABB2BF44",
        "editorLineNumber.activeForeground": "#ABB2BF77",
        "editorCursor.foreground": "#D66A57",
        "editor.selectionBackground": "#D66A5730",
        "editor.inactiveSelectionBackground": "#D66A5715",
        "editorIndentGuide.background": "#FFFFFF08",
        focusBorder: "#00000000",
        "editorHoverWidget.background": "#1F1212",
        "editorHoverWidget.border": "#E0D6C815",
        "editorHoverWidget.foreground": "#E0D6C8",
        "editorHoverWidget.statusBarBackground": "#291818",
        "editorMarkerNavigation.background": "#1F1212",
        "editorMarkerNavigationError.background": "#D66A5720",
      },
    });

    // ── Detect current theme ──────────────────────────────────────────────────

    function isDark() {
      return document.documentElement.classList.contains("dark");
    }

    function currentTheme() {
      return isDark() ? "ktr-dark" : "ktr-light";
    }

    // ── Read default code ──────────────────────────────────────────────────────

    var sources = JSON.parse(
      document.getElementById("default-code").textContent,
    );
    var currentTab = "tshirt";
    var tabContents = { tshirt: sources.tshirt, petal: sources.petal };
    var defaultCode = tabContents[currentTab];

    // ── Shared editor options ──────────────────────────────────────────────────

    var isMobile = window.matchMedia("(max-width: 767px)").matches;

    var sharedOptions = {
      fontSize: isMobile ? 12 : 13,
      fontFamily:
        "ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, 'Liberation Mono', monospace",
      lineHeight: isMobile ? 18 : 20,
      minimap: { enabled: false },
      scrollBeyondLastLine: false,
      renderLineHighlight: "none",
      overviewRulerLanes: 0,
      hideCursorInOverviewRuler: true,
      overviewRulerBorder: false,
      scrollbar: {
        vertical: "auto",
        horizontal: "auto",
        useShadows: false,
        verticalScrollbarSize: 8,
        horizontalScrollbarSize: 8,
      },
      padding: { top: 12, bottom: 12 },
      glyphMargin: false,
      folding: false,
      lineNumbersMinChars: 3,
      contextmenu: false,
      quickSuggestions: false,
      suggestOnTriggerCharacters: false,
      parameterHints: { enabled: false },
      wordBasedSuggestions: "off",
      hover: { enabled: true, above: true },
      lightbulb: { enabled: "off" },
      codeLens: false,
    };

    // ── Create editors ────────────────────────────────────────────────────────

    var inputEditor = monaco.editor.create(
      document.getElementById("editor-input"),
      Object.assign({}, sharedOptions, {
        value: defaultCode,
        language: "ktr",
        theme: currentTheme(),
        automaticLayout: true,
      }),
    );

    var outputEditor = monaco.editor.create(
      document.getElementById("editor-output"),
      Object.assign({}, sharedOptions, {
        value: "",
        language: "ktrir",
        theme: currentTheme(),
        automaticLayout: true,
      }),
    );

    // ── Theme sync ───────────────────────────────────────────────────────────

    var themeObserver = new MutationObserver(function () {
      var theme = currentTheme();
      monaco.editor.setTheme(theme);
    });
    themeObserver.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["class"],
    });

    // ── Source tabs ─────────────────────────────────────────────────────────

    var tabTshirtBtn = document.getElementById("tab-tshirt");
    var tabPetalBtn = document.getElementById("tab-petal");

    function setActiveTab(tab) {
      if (tab === currentTab) return;

      // Save current editor content for the current tab.
      tabContents[currentTab] = inputEditor.getValue();

      // Stop animation when switching.
      if (animating) stopAnimation();

      currentTab = tab;

      // Update button styles.
      var activeClass =
        "py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary";
      var inactiveClass =
        "py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary-muted-foreground/50";
      tabTshirtBtn.className = tab === "tshirt" ? activeClass : inactiveClass;
      tabPetalBtn.className = tab === "petal" ? activeClass : inactiveClass;

      // Load the tab's content into the editor and recompile.
      updating = true;
      inputEditor.setValue(tabContents[tab]);
      updating = false;

      // Reset state for the new tab.
      currentOverrides = {};
      lastCompiledIr = "";
      hideError();
      hideInputs();
      hideResults();
      clearMarkers(inputEditor);
      runCompile();

      // Auto-animate petal, not tshirt.
      if (tab === "petal") {
        startAnimation();
      }
    }

    tabTshirtBtn.addEventListener("click", function () {
      setActiveTab("tshirt");
    });
    tabPetalBtn.addEventListener("click", function () {
      setActiveTab("petal");
    });

    // ── Bidirectional compile / decompile wiring ──────────────────────────────

    var statusCompile = document.getElementById("status-compile");
    var statusDecompile = document.getElementById("status");
    var statusEval = document.getElementById("status-eval");
    var errorBar = document.getElementById("error-bar");
    var inputsContent = document.getElementById("inputs-content");
    var resultsContent = document.getElementById("results-content");
    var visualOutput = document.getElementById("visual-output");
    var textOutput = document.getElementById("text-output");
    var toggleVisualBtn = document.getElementById("toggle-visual");
    var toggleTextBtn = document.getElementById("toggle-text");
    var downloadSvgBtn = document.getElementById("download-svg");

    // Guard: prevents programmatic setValue from triggering the other direction.
    var updating = false;

    // Current input overrides and last compiled IR for re-evaluation.
    var currentOverrides = {};
    var lastCompiledIr = "";

    // Output mode: "visual" (default) or "text".
    var outputMode = "visual";
    var lastBindings = null;

    function setOutputMode(mode) {
      outputMode = mode;
      if (mode === "visual") {
        visualOutput.classList.remove("hidden");
        textOutput.classList.add("hidden");
        toggleVisualBtn.className =
          "py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary";
        toggleTextBtn.className =
          "py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary-muted-foreground/50";
      } else {
        visualOutput.classList.add("hidden");
        textOutput.classList.remove("hidden");
        toggleVisualBtn.className =
          "py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary-muted-foreground/50";
        toggleTextBtn.className =
          "py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary";
      }
      if (lastBindings) showResults(lastBindings);
    }

    toggleVisualBtn.addEventListener("click", function () {
      setOutputMode("visual");
    });
    toggleTextBtn.addEventListener("click", function () {
      setOutputMode("text");
    });

    downloadSvgBtn.addEventListener("click", function () {
      var svg = visualOutput.querySelector("svg");
      if (!svg) return;
      var clone = svg.cloneNode(true);
      clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
      // Add generator metadata as a comment and hash in filename.
      var version =
        "ktr 0.1.0 \u00b7 ktr-ir v1 \u00b7 Zig WASM runtime \u00b7 Release";
      var serializer = new XMLSerializer();
      var svgString = serializer.serializeToString(clone);
      svgString = "<!-- " + version + " -->\n" + svgString;
      // Simple hash from SVG content for the filename.
      var hash = 0;
      for (var i = 0; i < svgString.length; i++) {
        hash = ((hash << 5) - hash + svgString.charCodeAt(i)) | 0;
      }
      var hex = (hash >>> 0).toString(16).padStart(8, "0");
      var blob = new Blob([svgString], { type: "image/svg+xml" });
      var url = URL.createObjectURL(blob);
      var a = document.createElement("a");
      a.href = url;
      a.download = "pattern-" + hex + ".svg";
      a.click();
      URL.revokeObjectURL(url);
    });

    // ── Animation ────────────────────────────────────────────────────────────

    var toggleAnimateBtn = document.getElementById("toggle-animate");
    var iconPause = document.getElementById("icon-pause");
    var iconPlay = document.getElementById("icon-play");
    var inputsPane = document.getElementById("inputs-pane");

    var animating = false;
    var animationId = null;
    var userHasEdited = false;
    var inputsHovered = false;
    var defaultInputValues = {};
    var animFrameCount = 0;
    var animFpsTime = 0;

    function updateAnimateBtn() {
      if (animating) {
        iconPause.classList.remove("hidden");
        iconPlay.classList.add("hidden");
      } else {
        iconPause.classList.add("hidden");
        iconPlay.classList.remove("hidden");
      }
    }

    function startAnimation() {
      animating = true;
      userHasEdited = false;
      animFrameCount = 0;
      animFpsTime = performance.now();
      updateAnimateBtn();
      if (!animationId) animationId = requestAnimationFrame(animate);
    }

    function stopAnimation() {
      animating = false;
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      updateAnimateBtn();
      statusEval.textContent = "";
    }

    function animate() {
      animationId = null;
      if (!animating) return;

      if (inputsHovered || userHasEdited) {
        // Keep the loop alive but skip work.
        animationId = requestAnimationFrame(animate);
        return;
      }

      if (!lastBindings) {
        animationId = requestAnimationFrame(animate);
        return;
      }

      var t = performance.now() / 2000;
      var inputs = lastBindings.filter(function (b) {
        return b.isInput;
      });

      for (var i = 0; i < inputs.length; i++) {
        var inp = inputs[i];
        var def = defaultInputValues[inp.name];
        if (def === undefined) continue;
        var rate = 0.8 + i * 0.3;
        var s = (Math.sin(t * rate) + 1) / 2;
        var lo = def / 1.4;
        var hi = def * 1.4;
        currentOverrides[inp.name] = Math.max(1, lo + s * (hi - lo));
      }

      // Re-evaluate with animated overrides.
      if (lastCompiledIr) {
        var evalResult = evalIr(lastCompiledIr, currentOverrides);
        if (evalResult && evalResult.ok) {
          lastBindings = evalResult.bindings;
          var computed = evalResult.bindings.filter(function (b) {
            return !b.isInput;
          });
          if (outputMode === "visual") {
            renderVisual(computed);
          } else {
            renderTextResults(computed);
          }
          // Update input field values without rebuilding DOM.
          var fields = inputsContent.querySelectorAll("input[data-name]");
          for (var j = 0; j < fields.length; j++) {
            var name = fields[j].dataset.name;
            if (name in currentOverrides) {
              fields[j].value = Math.round(currentOverrides[name]);
            }
          }
          // Update FPS counter.
          animFrameCount++;
          var now = performance.now();
          if (now - animFpsTime >= 500) {
            var fps = Math.round((animFrameCount * 1000) / (now - animFpsTime));
            statusEval.textContent = fps + " fps";
            animFrameCount = 0;
            animFpsTime = now;
          }
        }
      }

      animationId = requestAnimationFrame(animate);
    }

    toggleAnimateBtn.addEventListener("click", function () {
      if (animating) {
        stopAnimation();
      } else {
        // Restart: clear user overrides and re-evaluate from defaults.
        userHasEdited = false;
        currentOverrides = {};
        if (lastCompiledIr) {
          var evalResult = evalIr(lastCompiledIr, currentOverrides);
          if (evalResult && evalResult.ok) {
            showInputs(evalResult.bindings);
            showResults(evalResult.bindings);
          }
        }
        startAnimation();
      }
    });

    var resetInputsBtn = document.getElementById("reset-inputs");
    resetInputsBtn.addEventListener("click", function () {
      stopAnimation();
      userHasEdited = false;
      currentOverrides = {};
      if (lastCompiledIr) {
        var evalResult = evalIr(lastCompiledIr, currentOverrides);
        if (evalResult && evalResult.ok) {
          showInputs(evalResult.bindings);
          showResults(evalResult.bindings);
        }
      }
    });

    // Pause animation while hovering over the input pane.
    inputsPane.addEventListener("mouseenter", function () {
      inputsHovered = true;
    });
    inputsPane.addEventListener("mouseleave", function () {
      inputsHovered = false;
    });

    // Parse error strings like "4:9:3: error: undefined reference"
    // into Monaco marker objects.
    function parseErrors(errorText) {
      var markers = [];
      var lines = errorText.split("\n");
      for (var i = 0; i < lines.length; i++) {
        var match = lines[i].match(/^(\d+):(\d+):(\d+): error: (.+)$/);
        if (match) {
          var line = parseInt(match[1], 10);
          var col = parseInt(match[2], 10);
          var len = parseInt(match[3], 10);
          markers.push({
            severity: monaco.MarkerSeverity.Error,
            startLineNumber: line,
            startColumn: col,
            endLineNumber: line,
            endColumn: col + Math.max(len, 1),
            message: match[4],
          });
        }
      }
      return markers;
    }

    function formatMs(ms) {
      if (ms < 0.1) return "< 0.1ms";
      if (ms < 1) return ms.toFixed(2) + "ms";
      if (ms < 10) return ms.toFixed(1) + "ms";
      return Math.round(ms) + "ms";
    }

    function showError(msg) {
      errorBar.textContent = msg;
    }

    function hideError() {
      errorBar.textContent = "";
    }

    function clearMarkers(editor) {
      monaco.editor.setModelMarkers(editor.getModel(), "ktrc", []);
    }

    function formatNumber(v) {
      if (!isFinite(v)) return String(v);
      if (v === Math.trunc(v)) return String(Math.trunc(v));
      // Round to 4 decimal places to avoid float noise like 35.666666666666664
      var rounded = Math.round(v * 10000) / 10000;
      return String(rounded);
    }

    function formatValue(binding) {
      var v = binding.value;
      // Bezier values come as {p1, p2, p3, p4} objects from the runtime.
      if (v !== null && typeof v === "object" && "p1" in v) {
        return (
          "bezier(" +
          ["p1", "p2", "p3", "p4"]
            .map(function (k) {
              return (
                "(" + formatNumber(v[k].x) + ", " + formatNumber(v[k].y) + ")"
              );
            })
            .join(", ") +
          ")"
        );
      }
      // Line values come as {start, end} objects from the runtime.
      if (v !== null && typeof v === "object" && "start" in v && "end" in v) {
        return (
          "line((" +
          formatNumber(v.start.x) +
          ", " +
          formatNumber(v.start.y) +
          "), (" +
          formatNumber(v.end.x) +
          ", " +
          formatNumber(v.end.y) +
          "))"
        );
      }
      // Point values come as {x, y} objects from the runtime.
      if (v !== null && typeof v === "object" && "x" in v) {
        return "(" + formatNumber(v.x) + ", " + formatNumber(v.y) + ")";
      }
      return formatNumber(v);
    }

    function formatType(binding) {
      if (binding.type === "length") return binding.unit;
      if (binding.type === "percentage") return "%";
      if (binding.type === "point") return "point";
      if (binding.type === "bezier") return "bezier";
      if (binding.type === "line") return "line";
      return binding.type;
    }

    // ── SVG visual renderer ──────────────────────────────────────────────────

    function renderVisual(computed) {
      var points = computed.filter(function (b) {
        return (
          b.type === "point" &&
          b.value !== null &&
          typeof b.value === "object" &&
          "x" in b.value
        );
      });

      var beziers = computed.filter(function (b) {
        return (
          b.type === "bezier" &&
          b.value !== null &&
          typeof b.value === "object" &&
          "p1" in b.value
        );
      });

      var lines = computed.filter(function (b) {
        return (
          b.type === "line" &&
          b.value !== null &&
          typeof b.value === "object" &&
          "start" in b.value &&
          "end" in b.value
        );
      });

      visualOutput.innerHTML = "";

      if (points.length === 0 && beziers.length === 0 && lines.length === 0) {
        var msg = document.createElement("span");
        msg.className = "text-xs font-mono text-primary-muted-foreground/40";
        msg.textContent = "No points to display";
        visualOutput.appendChild(msg);
        return;
      }

      // Compute bounding box from points, bezier control points, and line endpoints.
      var minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;

      function expandBounds(x, y) {
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      }

      for (var i = 0; i < points.length; i++) {
        expandBounds(points[i].value.x, points[i].value.y);
      }
      for (var i = 0; i < beziers.length; i++) {
        var bv = beziers[i].value;
        expandBounds(bv.p1.x, bv.p1.y);
        expandBounds(bv.p2.x, bv.p2.y);
        expandBounds(bv.p3.x, bv.p3.y);
        expandBounds(bv.p4.x, bv.p4.y);
      }
      for (var i = 0; i < lines.length; i++) {
        var lv = lines[i].value;
        expandBounds(lv.start.x, lv.start.y);
        expandBounds(lv.end.x, lv.end.y);
      }

      var rangeX = maxX - minX;
      var rangeY = maxY - minY;
      if (rangeX === 0 && rangeY === 0) {
        rangeX = 100;
        rangeY = 100;
        minX -= 50;
        minY -= 50;
      }
      var maxRange = Math.max(rangeX, rangeY);
      var pad = maxRange * 0.15;
      if (pad < 10) pad = 10;

      var vbX = minX - pad;
      var vbY = minY - pad;
      var vbW = rangeX + pad * 2;
      var vbH = rangeY + pad * 2;

      var svgNS = "http://www.w3.org/2000/svg";
      var svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("viewBox", vbX + " " + vbY + " " + vbW + " " + vbH);
      svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
      svg.setAttribute("class", "w-full h-full");

      var scale = Math.max(vbW, vbH);
      var dotR = scale * 0.008;
      var fontSize = scale * 0.012;
      var strokeW = scale * 0.004;
      var labelOffset = dotR + fontSize * 1.2;

      // Draw bezier curves first (behind points).
      for (var i = 0; i < beziers.length; i++) {
        var bz = beziers[i].value;
        var path = document.createElementNS(svgNS, "path");
        path.setAttribute(
          "d",
          "M " +
            bz.p1.x +
            " " +
            bz.p1.y +
            " C " +
            bz.p2.x +
            " " +
            bz.p2.y +
            ", " +
            bz.p3.x +
            " " +
            bz.p3.y +
            ", " +
            bz.p4.x +
            " " +
            bz.p4.y,
        );
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", "currentColor");
        path.setAttribute("stroke-width", strokeW);
        path.setAttribute("class", "text-primary");
        path.setAttribute("stroke-linecap", "round");
        svg.appendChild(path);

        // Draw a label at the curve midpoint (t=0.5).
        var t = 0.5;
        var mt = 1 - t;
        var mx =
          mt * mt * mt * bz.p1.x +
          3 * mt * mt * t * bz.p2.x +
          3 * mt * t * t * bz.p3.x +
          t * t * t * bz.p4.x;
        var my =
          mt * mt * mt * bz.p1.y +
          3 * mt * mt * t * bz.p2.y +
          3 * mt * t * t * bz.p3.y +
          t * t * t * bz.p4.y;

        var text = document.createElementNS(svgNS, "text");
        text.setAttribute("x", mx);
        text.setAttribute("y", my - labelOffset);
        text.setAttribute("text-anchor", "middle");
        text.setAttribute("font-size", fontSize);
        text.setAttribute(
          "font-family",
          "ui-monospace, SFMono-Regular, 'SF Mono', Menlo, monospace",
        );
        text.setAttribute("fill", "currentColor");
        text.setAttribute("class", "text-primary-muted-foreground/50");
        text.textContent = beziers[i].name;
        svg.appendChild(text);
      }

      // Draw line segments.
      for (var i = 0; i < lines.length; i++) {
        var ln = lines[i].value;
        var lineEl = document.createElementNS(svgNS, "line");
        lineEl.setAttribute("x1", ln.start.x);
        lineEl.setAttribute("y1", ln.start.y);
        lineEl.setAttribute("x2", ln.end.x);
        lineEl.setAttribute("y2", ln.end.y);
        lineEl.setAttribute("fill", "none");
        lineEl.setAttribute("stroke", "currentColor");
        lineEl.setAttribute("stroke-width", strokeW);
        lineEl.setAttribute("class", "text-primary svg-line");
        lineEl.setAttribute("stroke-linecap", "round");
        svg.appendChild(lineEl);

        // Draw a label at the midpoint.
        var lmx = (ln.start.x + ln.end.x) / 2;
        var lmy = (ln.start.y + ln.end.y) / 2;

        var lineLabel = document.createElementNS(svgNS, "text");
        lineLabel.setAttribute("x", lmx);
        lineLabel.setAttribute("y", lmy - labelOffset);
        lineLabel.setAttribute("text-anchor", "middle");
        lineLabel.setAttribute("font-size", fontSize);
        lineLabel.setAttribute(
          "font-family",
          "ui-monospace, SFMono-Regular, 'SF Mono', Menlo, monospace",
        );
        lineLabel.setAttribute("fill", "currentColor");
        lineLabel.setAttribute("class", "text-primary-muted-foreground/50");
        lineLabel.textContent = lines[i].name;
        svg.appendChild(lineLabel);
      }

      // Draw dots and labels.
      for (var i = 0; i < points.length; i++) {
        var pt = points[i];
        var cx = pt.value.x;
        var cy = pt.value.y;

        var g = document.createElementNS(svgNS, "g");
        g.setAttribute("class", "svg-point");
        g.style.cursor = "pointer";

        // Invisible hit area for easier hover interaction.
        var hitArea = document.createElementNS(svgNS, "circle");
        hitArea.setAttribute("cx", cx);
        hitArea.setAttribute("cy", cy);
        hitArea.setAttribute("r", dotR * 6);
        hitArea.setAttribute("fill", "transparent");
        g.appendChild(hitArea);

        var circle = document.createElementNS(svgNS, "circle");
        circle.setAttribute("cx", cx);
        circle.setAttribute("cy", cy);
        circle.setAttribute("r", dotR);
        circle.setAttribute("fill", "currentColor");
        circle.setAttribute("class", "text-primary");
        g.appendChild(circle);

        var text = document.createElementNS(svgNS, "text");
        text.setAttribute("x", cx);
        text.setAttribute("y", cy - labelOffset);
        text.setAttribute("text-anchor", "middle");
        text.setAttribute("font-size", fontSize);
        text.setAttribute(
          "font-family",
          "ui-monospace, SFMono-Regular, 'SF Mono', Menlo, monospace",
        );
        text.setAttribute("fill", "currentColor");
        text.setAttribute("class", "text-primary-muted-foreground/70");
        text.textContent = pt.name;
        g.appendChild(text);

        svg.appendChild(g);
      }

      visualOutput.appendChild(svg);
    }

    // ── Text results table ───────────────────────────────────────────────────

    function renderTextResults(computed) {
      resultsContent.innerHTML = "";
      var table = document.createElement("table");
      table.className = "w-full";
      for (var i = 0; i < computed.length; i++) {
        var b = computed[i];
        var tr = document.createElement("tr");
        tr.className = "leading-relaxed";

        var tdName = document.createElement("td");
        tdName.className =
          "pr-4 text-primary-muted-foreground/70 select-all whitespace-nowrap";
        tdName.textContent = b.name;

        var tdValue = document.createElement("td");
        tdValue.className =
          "text-foreground tabular-nums select-all text-right w-full";
        tdValue.textContent = formatValue(b);

        var tdType = document.createElement("td");
        tdType.className =
          "pl-2 text-primary-muted-foreground/60 whitespace-nowrap";
        tdType.textContent = formatType(b);

        tr.appendChild(tdName);
        tr.appendChild(tdValue);
        tr.appendChild(tdType);
        table.appendChild(tr);
      }
      resultsContent.appendChild(table);
    }

    // ── Show / hide results ──────────────────────────────────────────────────

    function showResults(bindings) {
      // Filter out input bindings — they're shown in the inputs panel.
      var computed = bindings.filter(function (b) {
        return !b.isInput;
      });
      lastBindings = bindings;

      if (computed.length === 0) {
        hideResults();
        return;
      }

      if (outputMode === "visual") {
        renderVisual(computed);
      } else {
        renderTextResults(computed);
      }
    }

    function hideResults() {
      visualOutput.innerHTML = "";
      resultsContent.innerHTML = "";
      lastBindings = null;
    }

    // ── Show / hide inputs ───────────────────────────────────────────────────

    function showInputs(bindings) {
      // Extract only the input bindings.
      var inputs = bindings.filter(function (b) {
        return b.isInput;
      });

      inputsContent.innerHTML = "";

      if (inputs.length === 0) {
        return;
      }

      var table = document.createElement("table");
      table.className = "w-full";

      for (var i = 0; i < inputs.length; i++) {
        (function (inp) {
          var tr = document.createElement("tr");
          tr.className = "leading-relaxed";

          // Name label
          var tdName = document.createElement("td");
          tdName.className =
            "pr-3 text-primary-muted-foreground/70 whitespace-nowrap align-middle";
          tdName.textContent = inp.name;

          // Editable value
          var tdValue = document.createElement("td");
          tdValue.className = "w-full align-middle";

          var inputEl = document.createElement("input");
          inputEl.type = "number";
          inputEl.step = "any";
          inputEl.className =
            "w-full bg-transparent border border-border rounded px-2 py-0.5 " +
            "text-foreground tabular-nums font-mono text-xs " +
            "focus:outline-none focus:border-primary/40 " +
            "appearance-none [&::-webkit-inner-spin-button]:appearance-none [&::-webkit-outer-spin-button]:appearance-none [-moz-appearance:textfield]";

          // Show the current override if set, otherwise the evaluated value.
          var currentVal =
            inp.name in currentOverrides
              ? currentOverrides[inp.name]
              : inp.value;
          inputEl.value = currentVal;
          inputEl.dataset.name = inp.name;
          inputEl.dataset.defaultValue = String(inp.value);

          inputEl.addEventListener("input", function () {
            // User manually edited — stop animation.
            if (animating) {
              userHasEdited = true;
              stopAnimation();
            }
            var val = parseFloat(inputEl.value);
            if (isNaN(val)) {
              delete currentOverrides[inp.name];
            } else {
              currentOverrides[inp.name] = val;
            }
            resetBtn.classList.toggle(
              "invisible",
              !(inp.name in currentOverrides) ||
                currentOverrides[inp.name] ===
                  parseFloat(inputEl.dataset.defaultValue),
            );
            reEvaluate();
          });

          tdValue.appendChild(inputEl);

          // Unit label
          var tdUnit = document.createElement("td");
          tdUnit.className =
            "pl-2 text-primary-muted-foreground/60 whitespace-nowrap align-middle";
          tdUnit.textContent = formatType(inp);

          // Reset button
          var tdReset = document.createElement("td");
          tdReset.className = "pl-1 align-middle";

          var resetBtn = document.createElement("button");
          resetBtn.className =
            "text-primary-muted-foreground/50 hover:text-primary-muted-foreground " +
            "text-[10px] leading-none cursor-pointer invisible";
          resetBtn.textContent = "\u21BA";
          resetBtn.title = "Reset to default";

          // Show reset button if override differs from default.
          if (
            inp.name in currentOverrides &&
            currentOverrides[inp.name] !==
              parseFloat(inputEl.dataset.defaultValue)
          ) {
            resetBtn.classList.remove("invisible");
          }

          resetBtn.addEventListener("click", function () {
            delete currentOverrides[inp.name];
            inputEl.value = parseFloat(inputEl.dataset.defaultValue);
            resetBtn.classList.add("invisible");
            reEvaluate();
          });

          tdReset.appendChild(resetBtn);

          tr.appendChild(tdName);
          tr.appendChild(tdValue);
          tr.appendChild(tdUnit);
          tr.appendChild(tdReset);
          table.appendChild(tr);
        })(inputs[i]);
      }

      inputsContent.appendChild(table);
    }

    function hideInputs() {
      inputsContent.innerHTML = "";
    }

    // Re-evaluate the last compiled IR with current overrides.
    function reEvaluate() {
      if (!lastCompiledIr) return;
      var t0 = performance.now();
      var evalResult = evalIr(lastCompiledIr, currentOverrides);
      if (evalResult && evalResult.ok) {
        showResults(evalResult.bindings);
        statusEval.textContent =
          "Evaluated in " + formatMs(performance.now() - t0);
      } else if (evalResult && !evalResult.ok) {
        showError("eval: " + evalResult.error);
      }
    }

    // .ktr → .ktrir → eval
    function runCompile() {
      if (!wasm) return;

      var source = inputEditor.getValue();
      if (source.trim().length === 0) {
        updating = true;
        outputEditor.setValue("");
        updating = false;
        hideError();
        hideInputs();
        hideResults();
        clearMarkers(inputEditor);
        statusCompile.textContent = "";
        statusEval.textContent = "";
        lastCompiledIr = "";
        currentOverrides = {};
        return;
      }

      var t0 = performance.now();
      var result = compileKtr(source);
      var compileElapsed = performance.now() - t0;

      if (result.ok) {
        updating = true;
        outputEditor.setValue(result.output);
        updating = false;
        hideError();
        clearMarkers(inputEditor);
        statusCompile.textContent = "Compiled in " + formatMs(compileElapsed);

        // Store for re-evaluation and reset overrides on recompile.
        lastCompiledIr = result.output;
        currentOverrides = {};

        // Evaluate the IR.
        var t1 = performance.now();
        var evalResult = evalIr(result.output, currentOverrides);
        if (evalResult && evalResult.ok) {
          // Capture default input values for animation.
          defaultInputValues = {};
          evalResult.bindings.forEach(function (b) {
            if (b.isInput) defaultInputValues[b.name] = b.value;
          });
          showInputs(evalResult.bindings);
          showResults(evalResult.bindings);
          statusEval.textContent =
            "Evaluated in " + formatMs(performance.now() - t1);
        } else if (evalResult && !evalResult.ok) {
          hideInputs();
          showError("eval: " + evalResult.error);
          statusEval.textContent = "";
        }
      } else {
        // Keep last valid IR and results visible; just show markers + error bar.
        var markers = parseErrors(result.error);
        monaco.editor.setModelMarkers(inputEditor.getModel(), "ktrc", markers);
        var messages = markers.map(function (m) {
          return m.startLineNumber + ":" + m.startColumn + ": " + m.message;
        });
        showError(messages.join("\n") || result.error);
        statusCompile.textContent = "Error in " + formatMs(compileElapsed);
      }
    }

    // .ktrir → .ktr
    function runDecompile() {
      if (!wasm) return;

      var irSource = outputEditor.getValue();
      if (irSource.trim().length === 0) {
        updating = true;
        inputEditor.setValue("");
        updating = false;
        hideError();
        hideInputs();
        hideResults();
        clearMarkers(outputEditor);
        statusDecompile.textContent = "";
        statusEval.textContent = "";
        lastCompiledIr = "";
        currentOverrides = {};
        return;
      }

      var t0 = performance.now();
      var result = decompileIr(irSource);
      var decompileElapsed = performance.now() - t0;

      if (result.ok) {
        updating = true;
        inputEditor.setValue(result.output);
        updating = false;
        hideError();
        clearMarkers(outputEditor);
        clearMarkers(inputEditor);
        statusDecompile.textContent =
          "Decompiled in " + formatMs(decompileElapsed);

        // Store for re-evaluation and reset overrides on decompile.
        lastCompiledIr = irSource;
        currentOverrides = {};

        // Also evaluate the IR.
        var t1 = performance.now();
        var evalResult = evalIr(irSource, currentOverrides);
        if (evalResult && evalResult.ok) {
          defaultInputValues = {};
          evalResult.bindings.forEach(function (b) {
            if (b.isInput) defaultInputValues[b.name] = b.value;
          });
          showInputs(evalResult.bindings);
          showResults(evalResult.bindings);
          statusEval.textContent =
            "Evaluated in " + formatMs(performance.now() - t1);
        } else if (evalResult && !evalResult.ok) {
          hideInputs();
          showError("eval: " + evalResult.error);
          statusEval.textContent = "";
        }
      } else {
        // Keep last valid source and results visible; just show error bar.
        showError(result.error);
        statusDecompile.textContent = "Error in " + formatMs(decompileElapsed);
      }
    }

    // Debounced listeners — skip when the other side is updating programmatically.
    var compileTimer = null;
    var decompileTimer = null;

    inputEditor.onDidChangeModelContent(function () {
      if (updating) return;
      if (decompileTimer) clearTimeout(decompileTimer);
      if (compileTimer) clearTimeout(compileTimer);
      compileTimer = setTimeout(runCompile, 200);
    });

    outputEditor.onDidChangeModelContent(function () {
      if (updating) return;
      if (compileTimer) clearTimeout(compileTimer);
      if (decompileTimer) clearTimeout(decompileTimer);
      decompileTimer = setTimeout(runDecompile, 200);
    });

    // ── Boot WASM ─────────────────────────────────────────────────────────────

    var versionEl = document.getElementById("version-info");

    statusDecompile.textContent = "Loading WASM\u2026";
    Promise.all([loadWasm(), loadRuntimeWasm()])
      .then(function (results) {
        wasm = results[0];
        wasmRuntime = results[1];
        statusDecompile.textContent = "";
        versionEl.textContent =
          "ktr 0.1.0 \u00b7 ktr-ir v1 \u00b7 Zig WASM runtime \u00b7 Release";
        runCompile();
      })
      .catch(function (err) {
        statusDecompile.textContent = "Failed to load WASM";
        console.error("WASM load error:", err);
      });
  });
</script>
