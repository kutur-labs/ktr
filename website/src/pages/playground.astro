---
import MainLayout from "../layouts/main-layout.astro";
import tshirtKtr from "./tshirt2.ktr?raw";
import petalKtr from "./petal.ktr?raw";
const sources = { tshirt: tshirtKtr, petal: petalKtr };
---

<MainLayout headerBorder>
  <main class="flex flex-col" style="height: calc(100dvh - 4rem);">
    <div
      class="grid grid-cols-1 md:grid-cols-2 grid-rows-4 md:grid-rows-2 flex-1 min-h-0"
    >
      <!-- Top-left: source.ktr editor -->
      <div
        class="flex flex-col min-h-0 min-w-0 border-b md:border-r border-border overflow-hidden"
      >
        <div
          class="flex items-center justify-between px-3 h-7 border-b border-border shrink-0"
        >
          <div class="flex items-center gap-1.5">
            <div class="flex items-center gap-2">
              <button
                id="tab-tshirt"
                class="py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary"
                >T-shirt</button
              >
              <button
                id="tab-petal"
                class="py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary-muted-foreground/50"
                >Petal</button
              >
            </div>
          </div>
          <span
            id="status-compile"
            class="text-[10px] font-mono text-primary-muted-foreground/50"
          ></span>
        </div>
        <div id="editor-input" class="flex-1 min-h-0 overflow-hidden"></div>
      </div>

      <!-- Top-right: inputs -->
      <div
        id="inputs-pane"
        class="flex flex-col min-h-0 min-w-0 border-b border-border overflow-hidden"
      >
        <div
          class="flex items-center justify-between px-3 h-7 border-b border-border shrink-0"
        >
          <div class="flex items-center gap-1.5">
            <span class="text-[10px] font-mono text-primary-muted-foreground"
              >Input</span
            >
            <button
              id="toggle-animate"
              class="cursor-pointer text-primary-muted-foreground/60 hover:text-primary-muted-foreground ml-1 leading-none"
              title="Play/pause animation"
              ><svg
                id="icon-pause"
                class="size-2 hidden"
                viewBox="0 0 16 16"
                fill="currentColor"
                xmlns="http://www.w3.org/2000/svg"
                ><rect x="3" y="2" width="4" height="12" rx="1"></rect><rect
                  x="9"
                  y="2"
                  width="4"
                  height="12"
                  rx="1"></rect></svg
              ><svg
                id="icon-play"
                class="size-2"
                viewBox="0 0 16 16"
                fill="currentColor"
                xmlns="http://www.w3.org/2000/svg"
                ><path
                  d="M4 2.5a.5.5 0 01.77-.42l9 5.5a.5.5 0 010 .84l-9 5.5A.5.5 0 014 13.5v-11z"
                ></path></svg
              ></button
            ><button
              id="reset-inputs"
              class="cursor-pointer text-primary-muted-foreground/60 hover:text-primary-muted-foreground ml-0.5 leading-none"
              title="Reset inputs"
              ><svg
                class="size-2"
                viewBox="0 0 16 16"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                ><path
                  d="M2 2v5h5M14 14v-5H9"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"></path><path
                  d="M13.5 6A6 6 0 005 3.5L2 7m12 3l-3 3.5A6 6 0 012.5 10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"></path></svg
              ></button
            >
          </div>
          <span
            id="status-eval"
            class="text-[10px] font-mono text-primary-muted-foreground/50"
          ></span>
        </div>
        <div
          id="inputs-content"
          class="px-3 py-2 font-mono text-xs flex-1 overflow-auto"
        >
        </div>
      </div>

      <!-- Bottom-left: source.ktrir editor -->
      <div
        class="flex flex-col min-h-0 min-w-0 border-b md:border-b-0 md:border-r border-border overflow-hidden"
      >
        <div
          class="flex items-center justify-between px-3 h-7 border-b border-border shrink-0"
        >
          <div class="flex items-center gap-1.5">
            <span class="text-[10px] font-mono text-primary-muted-foreground"
              >IR</span
            >
          </div>
          <span
            id="status"
            class="text-[10px] font-mono text-primary-muted-foreground/50"
          ></span>
        </div>
        <div id="editor-output" class="flex-1 min-h-0 overflow-hidden"></div>
      </div>

      <!-- Bottom-right: output (visual / text) -->
      <div class="flex flex-col min-h-0 min-w-0 overflow-hidden">
        <div
          class="flex items-center justify-between px-3 h-7 border-b border-border shrink-0"
        >
          <div class="flex items-center gap-1.5">
            <span class="text-[10px] font-mono text-primary-muted-foreground"
              >Output</span
            >
            <button
              id="download-svg"
              class="cursor-pointer text-primary-muted-foreground/60 hover:text-primary-muted-foreground ml-1 leading-none"
              title="Download SVG"
              ><svg
                class="size-2"
                viewBox="0 0 16 16"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                ><path
                  d="M8 1v9m0 0L4.5 6.5M8 10l3.5-3.5M2 12.5v1a1 1 0 001 1h10a1 1 0 001-1v-1"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"></path></svg
              ></button
            >
          </div>
          <div class="flex items-center gap-4">
            <button
              id="toggle-debug"
              class="py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary-muted-foreground/50"
              >Debug</button
            >

            <div class="flex items-center gap-2">
              <button
                id="toggle-layout-cut"
                class="py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary"
                >Cut</button
              >
              <button
                id="toggle-layout-assembled"
                class="py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary-muted-foreground/50"
                >Preview</button
              >
            </div>
            <div class="flex items-center gap-2">
              <button
                id="toggle-visual"
                class="py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary"
                >Visual</button
              >
              <button
                id="toggle-text"
                class="py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary-muted-foreground/50"
                >Text</button
              >
            </div>
          </div>
        </div>
        <div
          id="visual-output"
          class="flex-1 min-h-0 overflow-auto flex items-center justify-center"
        >
        </div>
        <div id="text-output" class="hidden flex-1 min-h-0 overflow-auto">
          <div id="results-content" class="px-3 py-2 font-mono text-xs"></div>
        </div>
      </div>
    </div>

    <!-- Bottom bar (fixed height to prevent layout shift) -->
    <div
      class="flex items-center justify-between gap-4 px-3 border-t border-border shrink-0 h-8 overflow-hidden"
    >
      <div
        id="error-bar"
        class="text-primary text-xs font-mono truncate flex-1"
      >
      </div>
      <span
        id="version-info"
        class="text-[10px] font-mono text-primary-muted-foreground/60 shrink-0 whitespace-nowrap"
      ></span>
    </div>
  </main>
</MainLayout>

<!-- Default code passed from Astro frontmatter -->
<script
  id="default-code"
  type="application/json"
  set:html={JSON.stringify(sources)}
/>

<style is:global>
  .monaco-editor .hover-row.status-bar .actions a {
    color: var(--primary) !important;
  }
  .svg-point {
    transition: opacity 0.15s ease;
  }
  .svg-point:hover text {
    fill-opacity: 1;
  }
  svg:has(.svg-point:hover) .svg-point:not(:hover) {
    opacity: 0.35;
  }
  svg:has(.svg-point:hover) path,
  svg:has(.svg-point:hover) line {
    opacity: 0.35;
  }
</style>

<!-- Monaco AMD loader from CDN -->
<script
  is:inline
  src="https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs/loader.js"
></script>

<script is:inline>
  // ─── Monaco setup ─────────────────────────────────────────────────────────

  var MONACO_CDN = "https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs";

  require.config({ paths: { vs: MONACO_CDN } });

  window.MonacoEnvironment = {
    getWorkerUrl: function () {
      return (
        "data:text/javascript;charset=utf-8," +
        encodeURIComponent(
          'self.MonacoEnvironment={baseUrl:"' +
            MONACO_CDN +
            '/"};importScripts("' +
            MONACO_CDN +
            '/base/worker/workerMain.js");',
        )
      );
    },
  };

  // ─── WASM ─────────────────────────────────────────────────────────────────

  var wasm = null;
  var wasmRuntime = null;
  var encoder = new TextEncoder();
  var decoder = new TextDecoder();

  function loadWasm() {
    return WebAssembly.instantiateStreaming(fetch("/ktrc.wasm"), {}).then(
      function (result) {
        return result.instance.exports;
      },
    );
  }

  function loadRuntimeWasm() {
    return WebAssembly.instantiateStreaming(fetch("/ktrr.wasm"), {}).then(
      function (result) {
        return result.instance.exports;
      },
    );
  }

  function writeToWasm(wasmInstance, text) {
    var encoded = encoder.encode(text);
    var ptr = wasmInstance.alloc(encoded.length);
    if (ptr === 0) throw new Error("WASM alloc failed");
    new Uint8Array(wasmInstance.memory.buffer, ptr, encoded.length).set(
      encoded,
    );
    return { ptr: ptr, len: encoded.length };
  }

  function readFromWasm(wasmInstance, ptr, len) {
    if (ptr === 0 || len === 0) return "";
    return decoder.decode(new Uint8Array(wasmInstance.memory.buffer, ptr, len));
  }

  function compileKtr(source) {
    var input = writeToWasm(wasm, source);
    try {
      var result = wasm.compile(input.ptr, input.len);
      if (result >= 0) {
        return {
          ok: true,
          output: readFromWasm(wasm, wasm.get_output_ptr(), result),
        };
      } else {
        var errPtr = wasm.get_error_ptr();
        var errLen = wasm.get_error_len();
        return {
          ok: false,
          error: readFromWasm(wasm, errPtr, errLen) || "Compilation failed",
        };
      }
    } finally {
      wasm.dealloc(input.ptr, input.len);
    }
  }

  function decompileIr(irSource) {
    var input = writeToWasm(wasm, irSource);
    try {
      var result = wasm.decompile_ir(input.ptr, input.len);
      if (result >= 0) {
        return {
          ok: true,
          output: readFromWasm(wasm, wasm.get_output_ptr(), result),
        };
      } else {
        var errPtr = wasm.get_error_ptr();
        var errLen = wasm.get_error_len();
        return {
          ok: false,
          error: readFromWasm(wasm, errPtr, errLen) || "Decompilation failed",
        };
      }
    } finally {
      wasm.dealloc(input.ptr, input.len);
    }
  }

  function evalIr(irSource, overrides) {
    if (!wasmRuntime) return null;

    // Set overrides via the WASM API.
    wasmRuntime.clear_overrides();
    if (overrides) {
      var keys = Object.keys(overrides);
      for (var i = 0; i < keys.length; i++) {
        var name = writeToWasm(wasmRuntime, keys[i]);
        wasmRuntime.set_override(name.ptr, name.len, overrides[keys[i]]);
        wasmRuntime.dealloc(name.ptr, name.len);
      }
    }

    var input = writeToWasm(wasmRuntime, irSource);
    try {
      var result = wasmRuntime.eval_ir(input.ptr, input.len);
      if (result >= 0) {
        var json = readFromWasm(
          wasmRuntime,
          wasmRuntime.get_output_ptr(),
          result,
        );
        return { ok: true, bindings: JSON.parse(json) };
      } else {
        var errPtr = wasmRuntime.get_error_ptr();
        var errLen = wasmRuntime.get_error_len();
        return {
          ok: false,
          error:
            readFromWasm(wasmRuntime, errPtr, errLen) || "Evaluation failed",
        };
      }
    } finally {
      wasmRuntime.dealloc(input.ptr, input.len);
    }
  }

  // ─── Monaco initialization ────────────────────────────────────────────────

  require(["vs/editor/editor.main"], function () {
    // Register ktr language
    monaco.languages.register({ id: "ktr" });
    monaco.languages.setMonarchTokensProvider("ktr", {
      keywords: [
        "input",
        "fn",
        "piece",
        "let",
        "return",
        "require",
        "export",
        "search",
        "assert",
        "as",
      ],
      searchKeywords: ["bounds", "initial", "tolerance"],
      typeKeywords: [
        "mm",
        "cm",
        "f64",
        "i64",
        "bool",
        "point",
        "bezier",
        "line",
        "length",
        "percentage",
      ],

      tokenizer: {
        root: [
          [/\/\/.*$/, "comment"],
          [/"(?:[^"\\]|\\.)*"/, "string"],
          [/\b\d+(\.\d+)?(mm|cm)\b/, "number.unit"],
          [/\b\d+(\.\d+)?%/, "number.percentage"],
          [/\b\d+\.\d+\b/, "number.float"],
          [/\b\d+\b/, "number"],
          [
            /[a-zA-Z_]\w*/,
            {
              cases: {
                "@keywords": "keyword",
                "@searchKeywords": "keyword.other",
                "@typeKeywords": "type",
                "@default": "identifier",
              },
            },
          ],
          [/==|!=|<=|>=|<|>/, "operator"],
          [/[+\-*/]/, "operator"],
          [/\.\./, "operator"],
          [/=/, "operator"],
          [/[{}()\[\]]/, "delimiter.bracket"],
          [/[:,]/, "delimiter"],
          [/\./, "delimiter"],
        ],
      },
    });

    // Register ktrir language
    monaco.languages.register({ id: "ktrir" });
    monaco.languages.setMonarchTokensProvider("ktrir", {
      tokenizer: {
        root: [
          [/#.*$/, "comment"],
          [/\b(input|fn|end|ret|call)\b/, "keyword"],
          [/%[a-zA-Z_]\w*/, "variable"],
          [/%\d+/, "variable"],
          [/\b(length|percentage|f64|point|bezier|line|bool)\b/, "type"],
          [
            /\b(add|sub|mul|div|point|bezier|line|point_x|point_y|line_p1|line_p2|bezier_p1|bezier_p2|bezier_p3|bezier_p4)\b(?=\s)/,
            "keyword.other",
          ],
          [/\b\d+(\.\d+)?(mm|cm)\b/, "number.unit"],
          [/\b\d+\.\d+\b/, "number.float"],
          [/\b\d+\b/, "number"],
          [/->/, "operator"],
          [/:/, "delimiter"],
          [/=/, "operator"],
        ],
      },
    });

    // ── Themes ────────────────────────────────────────────────────────────────

    monaco.editor.defineTheme("ktr-light", {
      base: "vs",
      inherit: false,
      rules: [
        { token: "comment", foreground: "998888" },
        { token: "string", foreground: "B87333" },
        { token: "keyword", foreground: "C41E3A" },
        { token: "keyword.other", foreground: "C41E3A" },
        { token: "type", foreground: "986801" },
        { token: "number", foreground: "B76B01" },
        { token: "number.unit", foreground: "B76B01" },
        { token: "number.float", foreground: "B76B01" },
        { token: "number.percentage", foreground: "B76B01" },
        { token: "operator", foreground: "5C4444" },
        { token: "delimiter", foreground: "5C4444" },
        { token: "delimiter.bracket", foreground: "5C4444" },
        { token: "variable", foreground: "C41E3A" },
        { token: "identifier", foreground: "3D2323" },
        { token: "", foreground: "3D2323" },
      ],
      colors: {
        "editor.background": "#00000000",
        "editor.foreground": "#3D2323",
        "editor.lineHighlightBackground": "#00000006",
        "editorStickyScroll.background": "#FDF8F6F2",
        "editorStickyScrollHover.background": "#F5EEEBF5",
        "editorStickyScroll.border": "#3D232318",
        "editorStickyScroll.shadow": "#00000014",
        "editorLineNumber.foreground": "#99888866",
        "editorLineNumber.activeForeground": "#99888899",
        "editorCursor.foreground": "#C41E3A",
        "editor.selectionBackground": "#C41E3A30",
        "editor.inactiveSelectionBackground": "#C41E3A15",
        "editorIndentGuide.background": "#00000008",
        focusBorder: "#00000000",
        "editorHoverWidget.background": "#FDF8F6",
        "editorHoverWidget.border": "#3D232318",
        "editorHoverWidget.foreground": "#3D2323",
        "editorHoverWidget.statusBarBackground": "#F5EEEB",
        "editorMarkerNavigation.background": "#FDF8F6",
        "editorMarkerNavigationError.background": "#C41E3A20",
      },
    });

    monaco.editor.defineTheme("ktr-dark", {
      base: "vs-dark",
      inherit: false,
      rules: [
        { token: "comment", foreground: "7F8C8D" },
        { token: "string", foreground: "E8A87C" },
        { token: "keyword", foreground: "D66A57" },
        { token: "keyword.other", foreground: "D66A57" },
        { token: "type", foreground: "E5C07B" },
        { token: "number", foreground: "D19A66" },
        { token: "number.unit", foreground: "D19A66" },
        { token: "number.float", foreground: "D19A66" },
        { token: "number.percentage", foreground: "D19A66" },
        { token: "operator", foreground: "ABB2BF" },
        { token: "delimiter", foreground: "ABB2BF" },
        { token: "delimiter.bracket", foreground: "ABB2BF" },
        { token: "variable", foreground: "D66A57" },
        { token: "identifier", foreground: "E0D6C8" },
        { token: "", foreground: "E0D6C8" },
      ],
      colors: {
        "editor.background": "#00000000",
        "editor.foreground": "#E0D6C8",
        "editor.lineHighlightBackground": "#FFFFFF06",
        "editorStickyScroll.background": "#1F1212F2",
        "editorStickyScrollHover.background": "#291818F5",
        "editorStickyScroll.border": "#E0D6C815",
        "editorStickyScroll.shadow": "#00000055",
        "editorLineNumber.foreground": "#ABB2BF44",
        "editorLineNumber.activeForeground": "#ABB2BF77",
        "editorCursor.foreground": "#D66A57",
        "editor.selectionBackground": "#D66A5730",
        "editor.inactiveSelectionBackground": "#D66A5715",
        "editorIndentGuide.background": "#FFFFFF08",
        focusBorder: "#00000000",
        "editorHoverWidget.background": "#1F1212",
        "editorHoverWidget.border": "#E0D6C815",
        "editorHoverWidget.foreground": "#E0D6C8",
        "editorHoverWidget.statusBarBackground": "#291818",
        "editorMarkerNavigation.background": "#1F1212",
        "editorMarkerNavigationError.background": "#D66A5720",
      },
    });

    // ── Detect current theme ──────────────────────────────────────────────────

    function isDark() {
      return document.documentElement.classList.contains("dark");
    }

    function currentTheme() {
      return isDark() ? "ktr-dark" : "ktr-light";
    }

    // ── Read default code ──────────────────────────────────────────────────────

    var sources = JSON.parse(
      document.getElementById("default-code").textContent,
    );
    var currentTab = "tshirt";
    var tabContents = { tshirt: sources.tshirt, petal: sources.petal };
    var defaultCode = tabContents[currentTab];

    // ── Shared editor options ──────────────────────────────────────────────────

    var isMobile = window.matchMedia("(max-width: 767px)").matches;

    var sharedOptions = {
      fontSize: isMobile ? 12 : 13,
      fontFamily:
        "ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, 'Liberation Mono', monospace",
      lineHeight: isMobile ? 18 : 20,
      minimap: { enabled: false },
      scrollBeyondLastLine: false,
      renderLineHighlight: "none",
      overviewRulerLanes: 0,
      hideCursorInOverviewRuler: true,
      overviewRulerBorder: false,
      scrollbar: {
        vertical: "auto",
        horizontal: "auto",
        useShadows: false,
        verticalScrollbarSize: 8,
        horizontalScrollbarSize: 8,
      },
      padding: { top: 12, bottom: 12 },
      glyphMargin: false,
      folding: false,
      lineNumbersMinChars: 3,
      contextmenu: false,
      quickSuggestions: false,
      suggestOnTriggerCharacters: false,
      parameterHints: { enabled: false },
      wordBasedSuggestions: "off",
      hover: { enabled: true, above: true },
      lightbulb: { enabled: "off" },
      codeLens: false,
      stickyScroll: { enabled: true },
    };

    // ── Create editors ────────────────────────────────────────────────────────

    var inputEditor = monaco.editor.create(
      document.getElementById("editor-input"),
      Object.assign({}, sharedOptions, {
        value: defaultCode,
        language: "ktr",
        theme: currentTheme(),
        automaticLayout: true,
      }),
    );

    var outputEditor = monaco.editor.create(
      document.getElementById("editor-output"),
      Object.assign({}, sharedOptions, {
        value: "",
        language: "ktrir",
        theme: currentTheme(),
        automaticLayout: true,
      }),
    );

    // ── Theme sync ───────────────────────────────────────────────────────────

    var themeObserver = new MutationObserver(function () {
      var theme = currentTheme();
      monaco.editor.setTheme(theme);
    });
    themeObserver.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["class"],
    });

    // ── Source tabs ─────────────────────────────────────────────────────────

    var tabTshirtBtn = document.getElementById("tab-tshirt");
    var tabPetalBtn = document.getElementById("tab-petal");

    function setActiveTab(tab) {
      if (tab === currentTab) return;

      // Save current editor content for the current tab.
      tabContents[currentTab] = inputEditor.getValue();

      // Stop animation when switching.
      if (animating) stopAnimation();

      currentTab = tab;

      // Update button styles.
      var activeClass =
        "py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary";
      var inactiveClass =
        "py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary-muted-foreground/50";
      tabTshirtBtn.className = tab === "tshirt" ? activeClass : inactiveClass;
      tabPetalBtn.className = tab === "petal" ? activeClass : inactiveClass;

      // Load the tab's content into the editor and recompile.
      updating = true;
      inputEditor.setValue(tabContents[tab]);
      updating = false;

      // Reset state for the new tab.
      currentOverrides = {};
      lastCompiledIr = "";
      hideError();
      hideInputs();
      hideResults();
      clearMarkers(inputEditor);
      runCompile();

      // Auto-animate petal, not tshirt.
      if (tab === "petal") {
        startAnimation();
      }
    }

    tabTshirtBtn.addEventListener("click", function () {
      setActiveTab("tshirt");
    });
    tabPetalBtn.addEventListener("click", function () {
      setActiveTab("petal");
    });

    // ── Bidirectional compile / decompile wiring ──────────────────────────────

    var statusCompile = document.getElementById("status-compile");
    var statusDecompile = document.getElementById("status");
    var statusEval = document.getElementById("status-eval");
    var errorBar = document.getElementById("error-bar");
    var inputsContent = document.getElementById("inputs-content");
    var resultsContent = document.getElementById("results-content");
    var visualOutput = document.getElementById("visual-output");
    var textOutput = document.getElementById("text-output");
    var toggleVisualBtn = document.getElementById("toggle-visual");
    var toggleTextBtn = document.getElementById("toggle-text");
    var toggleLayoutAssembledBtn = document.getElementById(
      "toggle-layout-assembled",
    );
    var toggleLayoutCutBtn = document.getElementById("toggle-layout-cut");
    var toggleDebugBtn = document.getElementById("toggle-debug");
    var downloadSvgBtn = document.getElementById("download-svg");

    // Guard: prevents programmatic setValue from triggering the other direction.
    var updating = false;

    // Current input overrides and last compiled IR for re-evaluation.
    var currentOverrides = {};
    var lastCompiledIr = "";

    // Output mode: "visual" (default) or "text".
    var outputMode = "visual";
    // Visual layout mode: "cut" (default) or "assembled".
    var visualLayoutMode = "cut";
    // Debug overlay mode: off by default, on shows labels/points.
    var debugMode = false;
    var lastBindings = null;

    function setOutputMode(mode) {
      outputMode = mode;
      if (mode === "visual") {
        visualOutput.classList.remove("hidden");
        textOutput.classList.add("hidden");
        toggleVisualBtn.className =
          "py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary";
        toggleTextBtn.className =
          "py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary-muted-foreground/50";
      } else {
        visualOutput.classList.add("hidden");
        textOutput.classList.remove("hidden");
        toggleVisualBtn.className =
          "py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary-muted-foreground/50";
        toggleTextBtn.className =
          "py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary";
      }
      if (lastBindings) showResults(lastBindings);
    }

    toggleVisualBtn.addEventListener("click", function () {
      setOutputMode("visual");
    });
    toggleTextBtn.addEventListener("click", function () {
      setOutputMode("text");
    });

    function setVisualLayoutMode(mode) {
      visualLayoutMode = mode;
      if (mode === "assembled") {
        toggleLayoutAssembledBtn.className =
          "py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary";
        toggleLayoutCutBtn.className =
          "py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary-muted-foreground/50";
      } else {
        toggleLayoutAssembledBtn.className =
          "py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary-muted-foreground/50";
        toggleLayoutCutBtn.className =
          "py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary";
      }
      if (lastBindings && outputMode === "visual") showResults(lastBindings);
    }

    toggleLayoutAssembledBtn.addEventListener("click", function () {
      setVisualLayoutMode("assembled");
    });
    toggleLayoutCutBtn.addEventListener("click", function () {
      setVisualLayoutMode("cut");
    });

    function setDebugMode(enabled) {
      debugMode = enabled;
      if (enabled) {
        toggleDebugBtn.className =
          "py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary";
      } else {
        toggleDebugBtn.className =
          "py-0.5 text-[10px] font-mono rounded cursor-pointer text-primary-muted-foreground/50";
      }
      if (lastBindings && outputMode === "visual") showResults(lastBindings);
    }

    toggleDebugBtn.addEventListener("click", function () {
      setDebugMode(!debugMode);
    });

    downloadSvgBtn.addEventListener("click", function () {
      var svg = visualOutput.querySelector("svg");
      if (!svg) return;
      var clone = svg.cloneNode(true);
      clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
      // Add generator metadata as a comment and hash in filename.
      var version =
        "ktr 0.1.0 \u00b7 ktr-ir v1 \u00b7 Zig WASM runtime \u00b7 Release";
      var serializer = new XMLSerializer();
      var svgString = serializer.serializeToString(clone);
      svgString = "<!-- " + version + " -->\n" + svgString;
      // Simple hash from SVG content for the filename.
      var hash = 0;
      for (var i = 0; i < svgString.length; i++) {
        hash = ((hash << 5) - hash + svgString.charCodeAt(i)) | 0;
      }
      var hex = (hash >>> 0).toString(16).padStart(8, "0");
      var blob = new Blob([svgString], { type: "image/svg+xml" });
      var url = URL.createObjectURL(blob);
      var a = document.createElement("a");
      a.href = url;
      a.download = "pattern-" + hex + ".svg";
      a.click();
      URL.revokeObjectURL(url);
    });

    // ── Animation ────────────────────────────────────────────────────────────

    var toggleAnimateBtn = document.getElementById("toggle-animate");
    var iconPause = document.getElementById("icon-pause");
    var iconPlay = document.getElementById("icon-play");
    var inputsPane = document.getElementById("inputs-pane");

    var animating = false;
    var animationId = null;
    var userHasEdited = false;
    var inputsHovered = false;
    var defaultInputValues = {};
    var animFrameCount = 0;
    var animFpsTime = 0;

    function updateAnimateBtn() {
      if (animating) {
        iconPause.classList.remove("hidden");
        iconPlay.classList.add("hidden");
      } else {
        iconPause.classList.add("hidden");
        iconPlay.classList.remove("hidden");
      }
    }

    function startAnimation() {
      animating = true;
      userHasEdited = false;
      animFrameCount = 0;
      animFpsTime = performance.now();
      updateAnimateBtn();
      if (!animationId) animationId = requestAnimationFrame(animate);
    }

    function stopAnimation() {
      animating = false;
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      updateAnimateBtn();
      statusEval.textContent = "";
    }

    function animate() {
      animationId = null;
      if (!animating) return;

      if (inputsHovered || userHasEdited) {
        // Keep the loop alive but skip work.
        animationId = requestAnimationFrame(animate);
        return;
      }

      if (!lastBindings) {
        animationId = requestAnimationFrame(animate);
        return;
      }

      var t = performance.now() / 2000;
      var inputs = lastBindings.filter(function (b) {
        return b.isInput;
      });

      for (var i = 0; i < inputs.length; i++) {
        var inp = inputs[i];
        var def = defaultInputValues[inp.name];
        if (def === undefined) continue;
        var rate = 0.8 + i * 0.3;
        var s = (Math.sin(t * rate) + 1) / 2;
        var lo = def / 1.4;
        var hi = def * 1.4;
        currentOverrides[inp.name] = Math.max(1, lo + s * (hi - lo));
      }

      // Re-evaluate with animated overrides.
      if (lastCompiledIr) {
        var evalResult = evalIr(lastCompiledIr, currentOverrides);
        if (evalResult && evalResult.ok) {
          lastBindings = evalResult.bindings;
          var computed = evalResult.bindings.filter(isComputedDisplayBinding);
          if (outputMode === "visual") {
            renderVisual(computed);
          } else {
            renderTextResults(computed);
          }
          // Update input field values without rebuilding DOM.
          var fields = inputsContent.querySelectorAll("input[data-name]");
          for (var j = 0; j < fields.length; j++) {
            var name = fields[j].dataset.name;
            if (name in currentOverrides) {
              fields[j].value = Math.round(currentOverrides[name]);
            }
          }
          // Update FPS counter.
          animFrameCount++;
          var now = performance.now();
          if (now - animFpsTime >= 500) {
            var fps = Math.round((animFrameCount * 1000) / (now - animFpsTime));
            statusEval.textContent = fps + " fps";
            animFrameCount = 0;
            animFpsTime = now;
          }
        }
      }

      animationId = requestAnimationFrame(animate);
    }

    toggleAnimateBtn.addEventListener("click", function () {
      if (animating) {
        stopAnimation();
      } else {
        // Restart: clear user overrides and re-evaluate from defaults.
        userHasEdited = false;
        currentOverrides = {};
        if (lastCompiledIr) {
          var evalResult = evalIr(lastCompiledIr, currentOverrides);
          if (evalResult && evalResult.ok) {
            showInputs(evalResult.bindings);
            showResults(evalResult.bindings);
          }
        }
        startAnimation();
      }
    });

    var resetInputsBtn = document.getElementById("reset-inputs");
    resetInputsBtn.addEventListener("click", function () {
      stopAnimation();
      userHasEdited = false;
      currentOverrides = {};
      if (lastCompiledIr) {
        var evalResult = evalIr(lastCompiledIr, currentOverrides);
        if (evalResult && evalResult.ok) {
          showInputs(evalResult.bindings);
          showResults(evalResult.bindings);
        }
      }
    });

    // Pause animation while hovering over the input pane.
    inputsPane.addEventListener("mouseenter", function () {
      inputsHovered = true;
    });
    inputsPane.addEventListener("mouseleave", function () {
      inputsHovered = false;
    });

    // Parse error strings like "4:9:3: error: undefined reference"
    // into Monaco marker objects.
    function parseErrors(errorText) {
      var markers = [];
      var lines = errorText.split("\n");
      for (var i = 0; i < lines.length; i++) {
        var match = lines[i].match(/^(\d+):(\d+):(\d+): error: (.+)$/);
        if (match) {
          var line = parseInt(match[1], 10);
          var col = parseInt(match[2], 10);
          var len = parseInt(match[3], 10);
          markers.push({
            severity: monaco.MarkerSeverity.Error,
            startLineNumber: line,
            startColumn: col,
            endLineNumber: line,
            endColumn: col + Math.max(len, 1),
            message: match[4],
          });
        }
      }
      return markers;
    }

    function formatMs(ms) {
      if (ms < 0.1) return "< 0.1ms";
      if (ms < 1) return ms.toFixed(2) + "ms";
      if (ms < 10) return ms.toFixed(1) + "ms";
      return Math.round(ms) + "ms";
    }

    function showError(msg) {
      errorBar.textContent = msg;
    }

    function hideError() {
      errorBar.textContent = "";
    }

    function clearMarkers(editor) {
      monaco.editor.setModelMarkers(editor.getModel(), "ktrc", []);
    }

    function formatNumber(v) {
      if (!isFinite(v)) return String(v);
      if (v === Math.trunc(v)) return String(Math.trunc(v));
      // Round to 4 decimal places to avoid float noise like 35.666666666666664
      var rounded = Math.round(v * 10000) / 10000;
      return String(rounded);
    }

    function formatValue(binding) {
      var v = binding.value;
      if (binding.type === "piece") {
        // Piece members are already displayed as qualified bindings.
        return "";
      }
      // Bezier values come as {p1, p2, p3, p4} objects from the runtime.
      if (v !== null && typeof v === "object" && "p1" in v) {
        return (
          "bezier(" +
          ["p1", "p2", "p3", "p4"]
            .map(function (k) {
              return (
                "(" + formatNumber(v[k].x) + ", " + formatNumber(v[k].y) + ")"
              );
            })
            .join(", ") +
          ")"
        );
      }
      // Line values come as {start, end} objects from the runtime.
      if (v !== null && typeof v === "object" && "start" in v && "end" in v) {
        return (
          "line((" +
          formatNumber(v.start.x) +
          ", " +
          formatNumber(v.start.y) +
          "), (" +
          formatNumber(v.end.x) +
          ", " +
          formatNumber(v.end.y) +
          "))"
        );
      }
      // Point values come as {x, y} objects from the runtime.
      if (v !== null && typeof v === "object" && "x" in v) {
        return "(" + formatNumber(v.x) + ", " + formatNumber(v.y) + ")";
      }
      return formatNumber(v);
    }

    function formatType(binding) {
      if (binding.type === "length") return binding.unit;
      if (binding.type === "percentage") return "%";
      if (binding.type === "point") return "point";
      if (binding.type === "bezier") return "bezier";
      if (binding.type === "line") return "line";
      return binding.type;
    }

    function isComputedDisplayBinding(binding) {
      // Inputs are rendered in the inputs panel. Omit top-level piece values
      // from output because members are already listed individually.
      return !binding.isInput && binding.type !== "piece";
    }

    // ── SVG visual renderer ──────────────────────────────────────────────────

    function renderVisual(computed) {
      var points = computed.filter(function (b) {
        return (
          b.type === "point" &&
          b.value !== null &&
          typeof b.value === "object" &&
          "x" in b.value
        );
      });

      var beziers = computed.filter(function (b) {
        return (
          b.type === "bezier" &&
          b.value !== null &&
          typeof b.value === "object" &&
          "p1" in b.value
        );
      });

      var lines = computed.filter(function (b) {
        return (
          b.type === "line" &&
          b.value !== null &&
          typeof b.value === "object" &&
          "start" in b.value &&
          "end" in b.value
        );
      });

      visualOutput.innerHTML = "";

      if (points.length === 0 && beziers.length === 0 && lines.length === 0) {
        var msg = document.createElement("span");
        msg.className = "text-xs font-mono text-primary-muted-foreground/40";
        msg.textContent = "No points to display";
        visualOutput.appendChild(msg);
        return;
      }
      if (!debugMode && beziers.length === 0 && lines.length === 0) {
        var msg = document.createElement("span");
        msg.className = "text-xs font-mono text-primary-muted-foreground/40";
        msg.textContent = "No lines or beziers to display";
        visualOutput.appendChild(msg);
        return;
      }

      function getPieceGroupName(bindingName) {
        var dot = bindingName.indexOf(".");
        if (dot === -1) return "default";
        return bindingName.slice(0, dot);
      }

      function getMemberDisplayName(bindingName) {
        if (visualLayoutMode !== "cut") return bindingName;
        var dot = bindingName.indexOf(".");
        if (dot === -1) return bindingName;
        return bindingName.slice(dot + 1);
      }

      var svgNS = "http://www.w3.org/2000/svg";
      var svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
      svg.setAttribute("class", "w-full h-full");

      var groupOffsets = {};
      var pieceLayoutGroups = [];
      var vbX = 0;
      var vbY = 0;
      var vbW = 0;
      var vbH = 0;

      if (visualLayoutMode === "cut") {
        var grouped = {};
        var groupOrder = [];

        function ensureGroup(name) {
          var g = grouped[name];
          if (!g) {
            g = {
              name: name,
              minX: Infinity,
              minY: Infinity,
              maxX: -Infinity,
              maxY: -Infinity,
            };
            grouped[name] = g;
            groupOrder.push(name);
          }
          return g;
        }

        function expandGroup(g, x, y) {
          if (x < g.minX) g.minX = x;
          if (y < g.minY) g.minY = y;
          if (x > g.maxX) g.maxX = x;
          if (y > g.maxY) g.maxY = y;
        }

        if (debugMode) {
          for (var i = 0; i < points.length; i++) {
            var gp = ensureGroup(getPieceGroupName(points[i].name));
            expandGroup(gp, points[i].value.x, points[i].value.y);
          }
        }
        for (var i = 0; i < beziers.length; i++) {
          var gb = ensureGroup(getPieceGroupName(beziers[i].name));
          var bv = beziers[i].value;
          expandGroup(gb, bv.p1.x, bv.p1.y);
          expandGroup(gb, bv.p2.x, bv.p2.y);
          expandGroup(gb, bv.p3.x, bv.p3.y);
          expandGroup(gb, bv.p4.x, bv.p4.y);
        }
        for (var i = 0; i < lines.length; i++) {
          var gl = ensureGroup(getPieceGroupName(lines[i].name));
          var lv = lines[i].value;
          expandGroup(gl, lv.start.x, lv.start.y);
          expandGroup(gl, lv.end.x, lv.end.y);
        }

        var layoutPad = 24;
        var labelBand = debugMode ? 34 : 0;
        var groupGap = 64;
        var cursorX = layoutPad;
        var contentMaxY = layoutPad + labelBand;

        for (var i = 0; i < groupOrder.length; i++) {
          var group = grouped[groupOrder[i]];
          var width = Math.max(1, group.maxX - group.minX);
          var dx = cursorX - group.minX;
          var dy = layoutPad + labelBand - group.minY;
          groupOffsets[group.name] = { x: dx, y: dy };
          group.layout = {
            minX: group.minX + dx,
            minY: group.minY + dy,
            maxX: group.maxX + dx,
            maxY: group.maxY + dy,
          };
          pieceLayoutGroups.push(group);
          cursorX += width + groupGap;
          if (group.layout.maxY > contentMaxY) contentMaxY = group.layout.maxY;
        }

        vbX = 0;
        vbY = 0;
        vbW = Math.max(200, cursorX - groupGap + layoutPad);
        vbH = Math.max(140, contentMaxY + layoutPad);
      } else {
        // Visualize mode: keep all geometry in source-space coordinates.
        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;

        function expandBounds(x, y) {
          if (x < minX) minX = x;
          if (y < minY) minY = y;
          if (x > maxX) maxX = x;
          if (y > maxY) maxY = y;
        }

        if (debugMode) {
          for (var i = 0; i < points.length; i++) {
            expandBounds(points[i].value.x, points[i].value.y);
          }
        }
        for (var i = 0; i < beziers.length; i++) {
          var bv = beziers[i].value;
          expandBounds(bv.p1.x, bv.p1.y);
          expandBounds(bv.p2.x, bv.p2.y);
          expandBounds(bv.p3.x, bv.p3.y);
          expandBounds(bv.p4.x, bv.p4.y);
        }
        for (var i = 0; i < lines.length; i++) {
          var lv = lines[i].value;
          expandBounds(lv.start.x, lv.start.y);
          expandBounds(lv.end.x, lv.end.y);
        }

        var rangeX = maxX - minX;
        var rangeY = maxY - minY;
        if (rangeX === 0 && rangeY === 0) {
          rangeX = 100;
          rangeY = 100;
          minX -= 50;
          minY -= 50;
        }
        var maxRange = Math.max(rangeX, rangeY);
        var pad = maxRange * 0.15;
        if (pad < 10) pad = 10;

        vbX = minX - pad;
        vbY = minY - pad;
        vbW = rangeX + pad * 2;
        vbH = rangeY + pad * 2;
      }

      // Match the viewBox aspect ratio to the output pane so the SVG fills
      // the available width/height without leaving letterboxed bands.
      var viewportW = visualOutput.clientWidth;
      var viewportH = visualOutput.clientHeight;
      if (viewportW > 0 && viewportH > 0 && vbW > 0 && vbH > 0) {
        var targetAspect = viewportW / viewportH;
        var boxAspect = vbW / vbH;
        if (boxAspect > targetAspect) {
          var expandedH = vbW / targetAspect;
          var deltaH = expandedH - vbH;
          vbY -= deltaH / 2;
          vbH = expandedH;
        } else if (boxAspect < targetAspect) {
          var expandedW = vbH * targetAspect;
          var deltaW = expandedW - vbW;
          vbX -= deltaW / 2;
          vbW = expandedW;
        }
      }

      function withOffset(bindingName, p) {
        var group = getPieceGroupName(bindingName);
        var off = groupOffsets[group];
        if (!off) return { x: p.x, y: p.y };
        return { x: p.x + off.x, y: p.y + off.y };
      }

      function niceStep(raw) {
        var value = Math.max(raw, 0.000001);
        var pow10 = Math.pow(10, Math.floor(Math.log10(value)));
        var unit = value / pow10;
        var base = 1;
        if (unit <= 1) {
          base = 1;
        } else if (unit <= 2) {
          base = 2;
        } else if (unit <= 5) {
          base = 5;
        } else {
          base = 10;
        }
        return base * pow10;
      }

      function formatScaleLength(value) {
        var rounded = Math.round(value * 10) / 10;
        if (Math.abs(rounded - Math.round(rounded)) < 0.05) {
          return Math.round(rounded) + " mm";
        }
        return rounded.toFixed(1) + " mm";
      }

      svg.setAttribute("viewBox", vbX + " " + vbY + " " + vbW + " " + vbH);

      var scale = Math.max(vbW, vbH);
      var dotR = scale * 0.008;
      var fontSize = scale * 0.012;
      var strokeW = scale * 0.004;
      var labelOffset = dotR + fontSize * 1.2;

      // Draw an adaptive background grid for scale readability.
      var minorGridStep = niceStep(Math.max(vbW, vbH) / 26);
      var majorGridStep = minorGridStep * 5;
      var minorGridPatternId = "grid-minor";
      var majorGridPatternId = "grid-major";
      var defs = document.createElementNS(svgNS, "defs");

      var minorPattern = document.createElementNS(svgNS, "pattern");
      minorPattern.setAttribute("id", minorGridPatternId);
      minorPattern.setAttribute("patternUnits", "userSpaceOnUse");
      minorPattern.setAttribute("width", minorGridStep);
      minorPattern.setAttribute("height", minorGridStep);
      var minorPath = document.createElementNS(svgNS, "path");
      minorPath.setAttribute(
        "d",
        "M " + minorGridStep + " 0 L 0 0 0 " + minorGridStep,
      );
      minorPath.setAttribute("fill", "none");
      minorPath.setAttribute("stroke", "currentColor");
      minorPath.setAttribute("stroke-width", strokeW * 0.25);
      minorPath.setAttribute("class", "text-primary-muted-foreground/20");
      minorPattern.appendChild(minorPath);
      defs.appendChild(minorPattern);

      var majorPattern = document.createElementNS(svgNS, "pattern");
      majorPattern.setAttribute("id", majorGridPatternId);
      majorPattern.setAttribute("patternUnits", "userSpaceOnUse");
      majorPattern.setAttribute("width", majorGridStep);
      majorPattern.setAttribute("height", majorGridStep);
      var majorPath = document.createElementNS(svgNS, "path");
      majorPath.setAttribute(
        "d",
        "M " + majorGridStep + " 0 L 0 0 0 " + majorGridStep,
      );
      majorPath.setAttribute("fill", "none");
      majorPath.setAttribute("stroke", "currentColor");
      majorPath.setAttribute("stroke-width", strokeW * 0.45);
      majorPath.setAttribute("class", "text-primary-muted-foreground/30");
      majorPattern.appendChild(majorPath);
      defs.appendChild(majorPattern);
      svg.appendChild(defs);

      var minorGrid = document.createElementNS(svgNS, "rect");
      minorGrid.setAttribute("x", vbX);
      minorGrid.setAttribute("y", vbY);
      minorGrid.setAttribute("width", vbW);
      minorGrid.setAttribute("height", vbH);
      minorGrid.setAttribute("fill", "url(#" + minorGridPatternId + ")");
      svg.appendChild(minorGrid);

      var majorGrid = document.createElementNS(svgNS, "rect");
      majorGrid.setAttribute("x", vbX);
      majorGrid.setAttribute("y", vbY);
      majorGrid.setAttribute("width", vbW);
      majorGrid.setAttribute("height", vbH);
      majorGrid.setAttribute("fill", "url(#" + majorGridPatternId + ")");
      svg.appendChild(majorGrid);

      if (visualLayoutMode === "cut" && debugMode) {
        for (var i = 0; i < pieceLayoutGroups.length; i++) {
          var piece = pieceLayoutGroups[i];
          var label = document.createElementNS(svgNS, "text");
          var labelY = piece.layout.minY - Math.max(fontSize * 1.4, 10);
          label.setAttribute("x", (piece.layout.minX + piece.layout.maxX) / 2);
          label.setAttribute("y", labelY);
          label.setAttribute("text-anchor", "middle");
          label.setAttribute("font-size", fontSize * 1.05);
          label.setAttribute(
            "font-family",
            "ui-monospace, SFMono-Regular, 'SF Mono', Menlo, monospace",
          );
          label.setAttribute("fill", "currentColor");
          label.setAttribute("class", "text-primary-muted-foreground/70");
          label.textContent = piece.name;
          svg.appendChild(label);
        }
      }

      // Draw bezier curves first (behind points).
      for (var i = 0; i < beziers.length; i++) {
        var bzi = beziers[i];
        var bz1 = withOffset(bzi.name, bzi.value.p1);
        var bz2 = withOffset(bzi.name, bzi.value.p2);
        var bz3 = withOffset(bzi.name, bzi.value.p3);
        var bz4 = withOffset(bzi.name, bzi.value.p4);
        var path = document.createElementNS(svgNS, "path");
        path.setAttribute(
          "d",
          "M " +
            bz1.x +
            " " +
            bz1.y +
            " C " +
            bz2.x +
            " " +
            bz2.y +
            ", " +
            bz3.x +
            " " +
            bz3.y +
            ", " +
            bz4.x +
            " " +
            bz4.y,
        );
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", "currentColor");
        path.setAttribute("stroke-width", strokeW);
        path.setAttribute("class", "text-primary");
        path.setAttribute("stroke-linecap", "round");
        svg.appendChild(path);

        if (debugMode) {
          // Draw a label at the curve midpoint (t=0.5).
          var t = 0.5;
          var mt = 1 - t;
          var mx =
            mt * mt * mt * bz1.x +
            3 * mt * mt * t * bz2.x +
            3 * mt * t * t * bz3.x +
            t * t * t * bz4.x;
          var my =
            mt * mt * mt * bz1.y +
            3 * mt * mt * t * bz2.y +
            3 * mt * t * t * bz3.y +
            t * t * t * bz4.y;

          var text = document.createElementNS(svgNS, "text");
          text.setAttribute("x", mx);
          text.setAttribute("y", my - labelOffset);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("font-size", fontSize);
          text.setAttribute(
            "font-family",
            "ui-monospace, SFMono-Regular, 'SF Mono', Menlo, monospace",
          );
          text.setAttribute("fill", "currentColor");
          text.setAttribute("class", "text-primary-muted-foreground/50");
          text.textContent = getMemberDisplayName(bzi.name);
          svg.appendChild(text);
        }
      }

      // Draw line segments.
      for (var i = 0; i < lines.length; i++) {
        var lineBinding = lines[i];
        var start = withOffset(lineBinding.name, lineBinding.value.start);
        var end = withOffset(lineBinding.name, lineBinding.value.end);
        var lineEl = document.createElementNS(svgNS, "line");
        lineEl.setAttribute("x1", start.x);
        lineEl.setAttribute("y1", start.y);
        lineEl.setAttribute("x2", end.x);
        lineEl.setAttribute("y2", end.y);
        lineEl.setAttribute("fill", "none");
        lineEl.setAttribute("stroke", "currentColor");
        lineEl.setAttribute("stroke-width", strokeW);
        lineEl.setAttribute("class", "text-primary svg-line");
        lineEl.setAttribute("stroke-linecap", "round");
        svg.appendChild(lineEl);

        if (debugMode) {
          // Draw a label at the midpoint.
          var lmx = (start.x + end.x) / 2;
          var lmy = (start.y + end.y) / 2;

          var lineLabel = document.createElementNS(svgNS, "text");
          lineLabel.setAttribute("x", lmx);
          lineLabel.setAttribute("y", lmy - labelOffset);
          lineLabel.setAttribute("text-anchor", "middle");
          lineLabel.setAttribute("font-size", fontSize);
          lineLabel.setAttribute(
            "font-family",
            "ui-monospace, SFMono-Regular, 'SF Mono', Menlo, monospace",
          );
          lineLabel.setAttribute("fill", "currentColor");
          lineLabel.setAttribute("class", "text-primary-muted-foreground/50");
          lineLabel.textContent = getMemberDisplayName(lineBinding.name);
          svg.appendChild(lineLabel);
        }
      }

      if (debugMode) {
        // Draw dots and labels.
        for (var i = 0; i < points.length; i++) {
          var pt = points[i];
          var offsetPt = withOffset(pt.name, pt.value);
          var cx = offsetPt.x;
          var cy = offsetPt.y;

          var g = document.createElementNS(svgNS, "g");
          g.setAttribute("class", "svg-point");
          g.style.cursor = "pointer";

          // Invisible hit area for easier hover interaction.
          var hitArea = document.createElementNS(svgNS, "circle");
          hitArea.setAttribute("cx", cx);
          hitArea.setAttribute("cy", cy);
          hitArea.setAttribute("r", dotR * 6);
          hitArea.setAttribute("fill", "transparent");
          g.appendChild(hitArea);

          var circle = document.createElementNS(svgNS, "circle");
          circle.setAttribute("cx", cx);
          circle.setAttribute("cy", cy);
          circle.setAttribute("r", dotR);
          circle.setAttribute("fill", "currentColor");
          circle.setAttribute("class", "text-primary");
          g.appendChild(circle);

          var text = document.createElementNS(svgNS, "text");
          text.setAttribute("x", cx);
          text.setAttribute("y", cy - labelOffset);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("font-size", fontSize);
          text.setAttribute(
            "font-family",
            "ui-monospace, SFMono-Regular, 'SF Mono', Menlo, monospace",
          );
          text.setAttribute("fill", "currentColor");
          text.setAttribute("class", "text-primary-muted-foreground/70");
          text.textContent = getMemberDisplayName(pt.name);
          g.appendChild(text);

          svg.appendChild(g);
        }
      }

      // Bottom-anchored scale reference line.
      var scaleMargin = Math.max(strokeW * 5, 10);
      var scaleLength = niceStep(vbW / 7);
      var maxScaleLength = Math.max((vbW - scaleMargin * 2) * 0.35, 1);
      if (scaleLength > maxScaleLength) {
        scaleLength = niceStep(maxScaleLength);
      }
      var scaleY = vbY + vbH - scaleMargin;
      var scaleX1 = vbX + scaleMargin;
      var scaleX2 = scaleX1 + scaleLength;
      var tickH = Math.max(strokeW * 3, 5);

      var scaleLine = document.createElementNS(svgNS, "line");
      scaleLine.setAttribute("x1", scaleX1);
      scaleLine.setAttribute("y1", scaleY);
      scaleLine.setAttribute("x2", scaleX2);
      scaleLine.setAttribute("y2", scaleY);
      scaleLine.setAttribute("stroke", "currentColor");
      scaleLine.setAttribute("stroke-width", strokeW * 0.9);
      scaleLine.setAttribute("stroke-linecap", "round");
      scaleLine.setAttribute("class", "text-primary-muted-foreground/80");
      svg.appendChild(scaleLine);

      var scaleTickLeft = document.createElementNS(svgNS, "line");
      scaleTickLeft.setAttribute("x1", scaleX1);
      scaleTickLeft.setAttribute("y1", scaleY - tickH / 2);
      scaleTickLeft.setAttribute("x2", scaleX1);
      scaleTickLeft.setAttribute("y2", scaleY + tickH / 2);
      scaleTickLeft.setAttribute("stroke", "currentColor");
      scaleTickLeft.setAttribute("stroke-width", strokeW * 0.9);
      scaleTickLeft.setAttribute("class", "text-primary-muted-foreground/80");
      svg.appendChild(scaleTickLeft);

      var scaleTickRight = document.createElementNS(svgNS, "line");
      scaleTickRight.setAttribute("x1", scaleX2);
      scaleTickRight.setAttribute("y1", scaleY - tickH / 2);
      scaleTickRight.setAttribute("x2", scaleX2);
      scaleTickRight.setAttribute("y2", scaleY + tickH / 2);
      scaleTickRight.setAttribute("stroke", "currentColor");
      scaleTickRight.setAttribute("stroke-width", strokeW * 0.9);
      scaleTickRight.setAttribute("class", "text-primary-muted-foreground/80");
      svg.appendChild(scaleTickRight);

      var scaleLabel = document.createElementNS(svgNS, "text");
      scaleLabel.setAttribute("x", (scaleX1 + scaleX2) / 2);
      scaleLabel.setAttribute("y", scaleY - Math.max(fontSize * 0.5, 4));
      scaleLabel.setAttribute("text-anchor", "middle");
      scaleLabel.setAttribute("font-size", fontSize * 0.9);
      scaleLabel.setAttribute(
        "font-family",
        "ui-monospace, SFMono-Regular, 'SF Mono', Menlo, monospace",
      );
      scaleLabel.setAttribute("fill", "currentColor");
      scaleLabel.setAttribute("class", "text-primary-muted-foreground/80");
      scaleLabel.textContent = formatScaleLength(scaleLength);
      svg.appendChild(scaleLabel);

      visualOutput.appendChild(svg);
    }

    // ── Text results table ───────────────────────────────────────────────────

    function renderTextResults(computed) {
      resultsContent.innerHTML = "";
      var table = document.createElement("table");
      table.className = "w-full";
      for (var i = 0; i < computed.length; i++) {
        var b = computed[i];
        var tr = document.createElement("tr");
        tr.className = "leading-relaxed";

        var tdName = document.createElement("td");
        tdName.className =
          "pr-4 text-primary-muted-foreground/70 select-all whitespace-nowrap";
        tdName.textContent = b.name;

        var tdValue = document.createElement("td");
        tdValue.className =
          "text-foreground tabular-nums select-all text-right w-full";
        tdValue.textContent = formatValue(b);

        var tdType = document.createElement("td");
        tdType.className =
          "pl-2 text-primary-muted-foreground/60 whitespace-nowrap";
        tdType.textContent = formatType(b);

        tr.appendChild(tdName);
        tr.appendChild(tdValue);
        tr.appendChild(tdType);
        table.appendChild(tr);
      }
      resultsContent.appendChild(table);
    }

    // ── Show / hide results ──────────────────────────────────────────────────

    function showResults(bindings) {
      var computed = bindings.filter(isComputedDisplayBinding);
      lastBindings = bindings;

      if (computed.length === 0) {
        hideResults();
        return;
      }

      if (outputMode === "visual") {
        renderVisual(computed);
      } else {
        renderTextResults(computed);
      }
    }

    function hideResults() {
      visualOutput.innerHTML = "";
      resultsContent.innerHTML = "";
      lastBindings = null;
    }

    // ── Show / hide inputs ───────────────────────────────────────────────────

    function showInputs(bindings) {
      // Extract only the input bindings.
      var inputs = bindings.filter(function (b) {
        return b.isInput;
      });

      inputsContent.innerHTML = "";

      if (inputs.length === 0) {
        return;
      }

      var table = document.createElement("table");
      table.className = "w-full";

      for (var i = 0; i < inputs.length; i++) {
        (function (inp) {
          var tr = document.createElement("tr");
          tr.className = "leading-relaxed";

          // Name label
          var tdName = document.createElement("td");
          tdName.className =
            "pr-3 text-primary-muted-foreground/70 whitespace-nowrap align-middle";
          tdName.textContent = inp.name;

          // Editable value
          var tdValue = document.createElement("td");
          tdValue.className = "w-full align-middle";

          var inputEl = document.createElement("input");
          inputEl.type = "number";
          inputEl.step = "any";
          inputEl.className =
            "w-full bg-transparent border border-border rounded px-2 py-0.5 " +
            "text-foreground tabular-nums font-mono text-xs " +
            "focus:outline-none focus:border-primary/40 " +
            "appearance-none [&::-webkit-inner-spin-button]:appearance-none [&::-webkit-outer-spin-button]:appearance-none [-moz-appearance:textfield]";

          // Show the current override if set, otherwise the evaluated value.
          var currentVal =
            inp.name in currentOverrides
              ? currentOverrides[inp.name]
              : inp.value;
          inputEl.value = currentVal;
          inputEl.dataset.name = inp.name;
          inputEl.dataset.defaultValue = String(inp.value);

          inputEl.addEventListener("input", function () {
            // User manually edited — stop animation.
            if (animating) {
              userHasEdited = true;
              stopAnimation();
            }
            var val = parseFloat(inputEl.value);
            if (isNaN(val)) {
              delete currentOverrides[inp.name];
            } else {
              currentOverrides[inp.name] = val;
            }
            resetBtn.classList.toggle(
              "invisible",
              !(inp.name in currentOverrides) ||
                currentOverrides[inp.name] ===
                  parseFloat(inputEl.dataset.defaultValue),
            );
            reEvaluate();
          });

          tdValue.appendChild(inputEl);

          // Unit label
          var tdUnit = document.createElement("td");
          tdUnit.className =
            "pl-2 text-primary-muted-foreground/60 whitespace-nowrap align-middle";
          tdUnit.textContent = formatType(inp);

          // Reset button
          var tdReset = document.createElement("td");
          tdReset.className = "pl-1 align-middle";

          var resetBtn = document.createElement("button");
          resetBtn.className =
            "text-primary-muted-foreground/50 hover:text-primary-muted-foreground " +
            "text-[10px] leading-none cursor-pointer invisible";
          resetBtn.textContent = "\u21BA";
          resetBtn.title = "Reset to default";

          // Show reset button if override differs from default.
          if (
            inp.name in currentOverrides &&
            currentOverrides[inp.name] !==
              parseFloat(inputEl.dataset.defaultValue)
          ) {
            resetBtn.classList.remove("invisible");
          }

          resetBtn.addEventListener("click", function () {
            delete currentOverrides[inp.name];
            inputEl.value = parseFloat(inputEl.dataset.defaultValue);
            resetBtn.classList.add("invisible");
            reEvaluate();
          });

          tdReset.appendChild(resetBtn);

          tr.appendChild(tdName);
          tr.appendChild(tdValue);
          tr.appendChild(tdUnit);
          tr.appendChild(tdReset);
          table.appendChild(tr);
        })(inputs[i]);
      }

      inputsContent.appendChild(table);
    }

    function hideInputs() {
      inputsContent.innerHTML = "";
    }

    // Re-evaluate the last compiled IR with current overrides.
    function reEvaluate() {
      if (!lastCompiledIr) return;
      var t0 = performance.now();
      var evalResult = evalIr(lastCompiledIr, currentOverrides);
      if (evalResult && evalResult.ok) {
        showResults(evalResult.bindings);
        statusEval.textContent =
          "Evaluated in " + formatMs(performance.now() - t0);
      } else if (evalResult && !evalResult.ok) {
        showError("eval: " + evalResult.error);
      }
    }

    // .ktr → .ktrir → eval
    function runCompile() {
      if (!wasm) return;

      var source = inputEditor.getValue();
      if (source.trim().length === 0) {
        updating = true;
        outputEditor.setValue("");
        updating = false;
        hideError();
        hideInputs();
        hideResults();
        clearMarkers(inputEditor);
        statusCompile.textContent = "";
        statusEval.textContent = "";
        lastCompiledIr = "";
        currentOverrides = {};
        return;
      }

      var t0 = performance.now();
      var result = compileKtr(source);
      var compileElapsed = performance.now() - t0;

      if (result.ok) {
        updating = true;
        outputEditor.setValue(result.output);
        updating = false;
        hideError();
        clearMarkers(inputEditor);
        statusCompile.textContent = "Compiled in " + formatMs(compileElapsed);

        // Store for re-evaluation and reset overrides on recompile.
        lastCompiledIr = result.output;
        currentOverrides = {};

        // Evaluate the IR.
        var t1 = performance.now();
        var evalResult = evalIr(result.output, currentOverrides);
        if (evalResult && evalResult.ok) {
          // Capture default input values for animation.
          defaultInputValues = {};
          evalResult.bindings.forEach(function (b) {
            if (b.isInput) defaultInputValues[b.name] = b.value;
          });
          showInputs(evalResult.bindings);
          showResults(evalResult.bindings);
          statusEval.textContent =
            "Evaluated in " + formatMs(performance.now() - t1);
        } else if (evalResult && !evalResult.ok) {
          hideInputs();
          showError("eval: " + evalResult.error);
          statusEval.textContent = "";
        }
      } else {
        // Keep last valid IR and results visible; just show markers + error bar.
        var markers = parseErrors(result.error);
        monaco.editor.setModelMarkers(inputEditor.getModel(), "ktrc", markers);
        var messages = markers.map(function (m) {
          return m.startLineNumber + ":" + m.startColumn + ": " + m.message;
        });
        showError(messages.join("\n") || result.error);
        statusCompile.textContent = "Error in " + formatMs(compileElapsed);
      }
    }

    // .ktrir → .ktr
    function runDecompile() {
      if (!wasm) return;

      var irSource = outputEditor.getValue();
      if (irSource.trim().length === 0) {
        updating = true;
        inputEditor.setValue("");
        updating = false;
        hideError();
        hideInputs();
        hideResults();
        clearMarkers(outputEditor);
        statusDecompile.textContent = "";
        statusEval.textContent = "";
        lastCompiledIr = "";
        currentOverrides = {};
        return;
      }

      var t0 = performance.now();
      var result = decompileIr(irSource);
      var decompileElapsed = performance.now() - t0;

      if (result.ok) {
        updating = true;
        inputEditor.setValue(result.output);
        updating = false;
        hideError();
        clearMarkers(outputEditor);
        clearMarkers(inputEditor);
        statusDecompile.textContent =
          "Decompiled in " + formatMs(decompileElapsed);

        // Store for re-evaluation and reset overrides on decompile.
        lastCompiledIr = irSource;
        currentOverrides = {};

        // Also evaluate the IR.
        var t1 = performance.now();
        var evalResult = evalIr(irSource, currentOverrides);
        if (evalResult && evalResult.ok) {
          defaultInputValues = {};
          evalResult.bindings.forEach(function (b) {
            if (b.isInput) defaultInputValues[b.name] = b.value;
          });
          showInputs(evalResult.bindings);
          showResults(evalResult.bindings);
          statusEval.textContent =
            "Evaluated in " + formatMs(performance.now() - t1);
        } else if (evalResult && !evalResult.ok) {
          hideInputs();
          showError("eval: " + evalResult.error);
          statusEval.textContent = "";
        }
      } else {
        // Keep last valid source and results visible; just show error bar.
        showError(result.error);
        statusDecompile.textContent = "Error in " + formatMs(decompileElapsed);
      }
    }

    // Debounced listeners — skip when the other side is updating programmatically.
    var compileTimer = null;
    var decompileTimer = null;

    inputEditor.onDidChangeModelContent(function () {
      if (updating) return;
      if (decompileTimer) clearTimeout(decompileTimer);
      if (compileTimer) clearTimeout(compileTimer);
      compileTimer = setTimeout(runCompile, 200);
    });

    outputEditor.onDidChangeModelContent(function () {
      if (updating) return;
      if (compileTimer) clearTimeout(compileTimer);
      if (decompileTimer) clearTimeout(decompileTimer);
      decompileTimer = setTimeout(runDecompile, 200);
    });

    // ── Boot WASM ─────────────────────────────────────────────────────────────

    var versionEl = document.getElementById("version-info");

    statusDecompile.textContent = "Loading WASM\u2026";
    Promise.all([loadWasm(), loadRuntimeWasm()])
      .then(function (results) {
        wasm = results[0];
        wasmRuntime = results[1];
        statusDecompile.textContent = "";
        versionEl.textContent =
          "ktr 0.1.0 \u00b7 ktr-ir v1 \u00b7 Zig WASM runtime \u00b7 Release";
        runCompile();
      })
      .catch(function (err) {
        statusDecompile.textContent = "Failed to load WASM";
        console.error("WASM load error:", err);
      });
  });
</script>
